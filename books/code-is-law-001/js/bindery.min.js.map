{"version":3,"file":"bindery.min.js","sources":["../build/constants/index.js","../build/dom/prefixer.js","../build/dom/classes.js","../build/dom/dom.js","../build/dom/safeMeasure.js","../build/dom/index.js","../build/utils/throttle.js","../build/utils/formatAsRanges.js","../build/utils/cssLength.js","../build/page-setup/defaultPageSetup.js","../build/page-setup/PageSetup.js","../build/rules/Rule.js","../build/runtimeOptionChecker/validateRuntimeOptions.js","../build/runtimeOptionChecker/RuntimeTypes.js","../build/rules/Counter.js","../build/rules/OutOfFlow.js","../build/rules/FullBleedSpread.js","../build/rules/FullBleedPage.js","../build/rules/Replace.js","../build/rules/Footnote.js","../node_modules/regionize/dist/regionize.esm.js","../build/book/Page.js","../build/book/orderPages.js","../build/book/Book.js","../build/book/annotatePages.js","../build/book/searchPages.js","../build/rules/PageReference.js","../build/utils/shallowEqual.js","../build/rules/PageBreak.js","../build/rules/RunningHeader.js","../build/rules/Split.js","../build/rules/index.js","../build/defaults/attributeRules.js","../build/makeBook/dedupeRules.js","../build/makeBook/RuleSet.js","../build/makeBook/recoverFromRule.js","../build/makeBook/estimateProgress.js","../build/makeBook/makeBook.js","../build/makeBook/getContent.js","../build/controls/labels.js","../build/controls/components.js","../build/controls/index.js","../build/viewer/padPages.js","../build/viewer/gridViewer.js","../build/viewer/sheetMarks.js","../build/viewer/sheetViewer.js","../build/viewer/orderPagesBooklet.js","../build/viewer/flipbookViewer.js","../build/viewer/scrollUtils.js","../build/viewer/listenForPrint.js","../build/viewer/Viewer.js","../build/viewer/error.js","../build/bindery.js","../build/index.js"],"sourcesContent":["export const classPrefix = BINDERY_CLASS_PREFIX;\nexport var SheetLayout;\n(function (SheetLayout) {\n    SheetLayout[\"PAGES\"] = \"pages\";\n    SheetLayout[\"SPREADS\"] = \"spreads\";\n    SheetLayout[\"BOOKLET\"] = \"booklet\";\n})(SheetLayout || (SheetLayout = {}));\nexport var SheetMarks;\n(function (SheetMarks) {\n    SheetMarks[SheetMarks[\"NONE\"] = 0] = \"NONE\";\n    SheetMarks[SheetMarks[\"CROP\"] = 1] = \"CROP\";\n    SheetMarks[SheetMarks[\"BLEED\"] = 2] = \"BLEED\";\n    SheetMarks[SheetMarks[\"BOTH\"] = 3] = \"BOTH\";\n})(SheetMarks || (SheetMarks = {}));\nexport var SheetSize;\n(function (SheetSize) {\n    SheetSize[\"AUTO\"] = \"auto\";\n    SheetSize[\"AUTO_BLEED\"] = \"auto-bleed\";\n    SheetSize[\"AUTO_MARKS\"] = \"auto-marks\";\n    SheetSize[\"LETTER_PORTRAIT\"] = \"letter-portrait\";\n    SheetSize[\"LETTER_LANDSCAPE\"] = \"letter-landscape\";\n    SheetSize[\"A4_PORTRAIT\"] = \"a4-portrait\";\n    SheetSize[\"A4_LANDSCAPE\"] = \"a4-landscape\";\n})(SheetSize || (SheetSize = {}));\nexport var ViewerMode;\n(function (ViewerMode) {\n    ViewerMode[\"FLIPBOOK\"] = \"flipbook\";\n    ViewerMode[\"PREVIEW\"] = \"preview\";\n    ViewerMode[\"PRINT\"] = \"print\";\n})(ViewerMode || (ViewerMode = {}));\n","//\n// prefix classes\nimport { classPrefix } from '../constants';\nconst prefixer = (str) => {\n    if (str[0] === '.') {\n        return `.${classPrefix}${str.substr(1)}`;\n    }\n    return `${classPrefix}${str}`;\n};\nexport default prefixer;\n","import prefix from './prefixer';\nimport { ViewerMode } from '../constants';\nconst classes = {\n    showBleed: 'show-bleed',\n    showCrop: 'show-crop',\n    showBleedMarks: 'show-bleed-marks',\n    isViewing: 'viewing',\n    viewPreview: 'view-preview',\n    viewPrint: 'view-print',\n    viewFlip: 'view-flip',\n    inProgress: 'in-progress',\n    leftPage: 'left',\n    rightPage: 'right',\n    isOverflowing: 'is-overflowing',\n    printSheet: 'print-sheet',\n    sheetSpread: 'print-sheet-spread',\n    sheetLeft: 'print-sheet-left',\n    sheetRight: 'print-sheet-right',\n    toNext: 'continues',\n    fromPrev: 'continuation',\n};\nObject.keys(classes).forEach(k => {\n    const key = k;\n    const val = classes[key];\n    classes[key] = prefix(val);\n});\nconst allModeClasses = [\n    classes.viewPreview,\n    classes.viewPrint,\n    classes.viewFlip,\n];\nconst classForMode = (mode) => {\n    switch (mode) {\n        case ViewerMode.PREVIEW:\n            return classes.viewPreview;\n        case ViewerMode.PRINT:\n            return classes.viewPrint;\n        case ViewerMode.FLIPBOOK:\n            return classes.viewFlip;\n        default:\n            throw Error(`Getting class for unknown mode: ${mode}`);\n    }\n};\nexport { classes, allModeClasses, classForMode };\n","import prefixer from './prefixer';\nconst isElement = (node) => node.nodeType === Node.ELEMENT_NODE;\nconst isObj = (val) => typeof val === 'object';\nconst isFunc = (val) => typeof val === 'function';\nconst isStr = (val) => typeof val === 'string';\nconst h = (tagName, classNames, attrs, ...children) => {\n    const el = document.createElement(tagName);\n    if (classNames)\n        el.className = classNames\n            .split('.')\n            .filter(txt => txt !== '')\n            .map(prefixer)\n            .join(' ');\n    if (attrs)\n        for (const k in attrs) {\n            // @ts-ignore TODO replace with hyperscript anyways\n            const v = attrs[k];\n            // @ts-ignore TODO replace with hyperscript anyways\n            if (isFunc(v))\n                el[k] = v;\n            else\n                el.setAttribute(k, v);\n        }\n    if (children)\n        el.append(...children);\n    return el;\n};\nconst div = (cls, ...children) => {\n    return h('div', cls, {}, ...children);\n};\nconst button = (cls, attrs, label) => {\n    return h('button', cls, attrs, label);\n};\nconst select = (cls, attrs, ...optionElements) => {\n    return h('select', cls, attrs, ...optionElements);\n};\nconst option = (attrs, label) => {\n    return h('option', null, attrs, label);\n};\nexport { h, div, button, select, option };\n","import c from './prefixer';\nimport { div } from './dom';\nconst safeMeasure = (el, measureCallback) => {\n    if (el.parentNode)\n        return measureCallback();\n    let measureArea = document.querySelector(c('.measure-area'));\n    if (!measureArea)\n        measureArea = document.body.appendChild(div('.measure-area'));\n    if (measureArea.firstElementChild !== el) {\n        measureArea.innerHTML = '';\n        measureArea.append(el);\n    }\n    const result = measureCallback();\n    return result;\n};\nexport default safeMeasure;\n","import { classes, classForMode, allModeClasses } from './classes';\nimport prefixer from './prefixer';\nimport safeMeasure from './safeMeasure';\nexport * from './dom';\nconst doc = window.document;\n// Create stylesheet with id\nconst addStylesheet = (id) => {\n    const style = doc.createElement('style');\n    style.id = id;\n    doc.head.appendChild(style);\n    return style;\n};\n// Fetch or create stylesheet with id\nconst stylesheet = (id) => {\n    var _a;\n    return (_a = doc.querySelector(`#${id}`)) !== null && _a !== void 0 ? _a : addStylesheet(id);\n};\n// Parse html from text\nconst parseHTML = (text, selector) => {\n    const wrapper = doc.createElement('div');\n    wrapper.innerHTML = text;\n    return selector ? wrapper.querySelector(selector) : wrapper;\n};\nexport { prefixer, classes, classForMode, allModeClasses, stylesheet, safeMeasure, parseHTML, };\n","const throttleFrame = () => {\n    let wasCalled = false;\n    let queued;\n    const inner = (func) => {\n        if (wasCalled) {\n            queued = func;\n            return;\n        }\n        wasCalled = true;\n        func();\n        requestAnimationFrame(() => {\n            wasCalled = false;\n            if (queued) {\n                const queuedFunc = queued;\n                queued = undefined;\n                inner(queuedFunc);\n            }\n        });\n    };\n    return inner;\n};\nconst throttleTime = (ms) => {\n    let wasCalled = false;\n    let queued;\n    const inner = (func) => {\n        if (wasCalled) {\n            queued = func;\n            return;\n        }\n        wasCalled = true;\n        func();\n        setTimeout(() => {\n            wasCalled = false;\n            if (queued) {\n                const queuedFunc = queued;\n                queued = undefined;\n                inner(queuedFunc);\n            }\n        }, ms);\n    };\n    return inner;\n};\nexport { throttleFrame, throttleTime };\n","const formatAsRanges = (pageNumbers) => {\n    let str = '';\n    let prevNum = pageNumbers[0];\n    let isInARange = false;\n    const addFirst = (num) => {\n        str += `${num}`;\n    };\n    const continueRange = () => {\n        isInARange = true;\n    };\n    const endRange = (endNum) => {\n        isInARange = false;\n        str += `â€“${endNum}`;\n    };\n    const addComma = (num) => {\n        str += `, ${num}`;\n    };\n    const endAndAdd = (endNum, num) => {\n        endRange(endNum);\n        addComma(num);\n    };\n    const addLast = (num, isAdjacent) => {\n        if (isAdjacent)\n            endRange(num);\n        else if (isInARange && !isAdjacent)\n            endAndAdd(prevNum, num);\n        else\n            addComma(num);\n    };\n    pageNumbers.forEach((num, i) => {\n        const isLast = i === pageNumbers.length - 1;\n        const isAdjacent = num === prevNum + 1;\n        if (i === 0)\n            addFirst(num);\n        else if (isLast)\n            addLast(num, isAdjacent);\n        else if (isAdjacent)\n            continueRange();\n        else if (isInARange && !isAdjacent)\n            endAndAdd(prevNum, num);\n        else\n            addComma(num);\n        prevNum = num;\n    });\n    return str;\n};\nexport default formatAsRanges;\n","const cssNumberRegEx = /^([+-]?[0-9]+(.?[0-9]+)?)(px|in|cm|mm|pt|pc)$/;\nconst isLength = (str) => cssNumberRegEx.test(str);\nconst parseLength = (str) => {\n    if (!isLength(str))\n        throw Error(`Cannot parse css length from \"${str}\"`);\n    const matches = str.match(cssNumberRegEx);\n    if (!matches) {\n        throw Error(`Failed to parse css length from \"${str}\"`);\n    }\n    return {\n        val: Number(matches[1]),\n        unit: matches[3],\n    };\n};\nexport { parseLength, isLength };\n","export default {\n    bleed: '12pt',\n    size: { width: '4in', height: '6in' },\n    margin: {\n        inner: '24pt',\n        outer: '24pt',\n        bottom: '40pt',\n        top: '48pt',\n    },\n};\n","import { stylesheet } from '../dom';\nimport { parseLength } from '../utils';\nimport defaultPageSetup from './defaultPageSetup';\nimport { SheetSize, SheetLayout } from '../constants';\nconst letter = Object.freeze({ width: '8.5in', height: '11in' });\nconst a4 = Object.freeze({ width: '210mm', height: '297mm' });\n// Not a really reliable way to know this\nconst supportsCustomPageSize = !!window.hasOwnProperty('chrome');\nclass PageSetup {\n    constructor(opts = {}, printOpts = {}) {\n        var _a, _b, _c;\n        this.size = (_a = opts.size) !== null && _a !== void 0 ? _a : defaultPageSetup.size;\n        this.margin = (_b = opts.margin) !== null && _b !== void 0 ? _b : defaultPageSetup.margin;\n        this.markLength = '12pt';\n        this.paper = supportsCustomPageSize\n            ? printOpts.paper || SheetSize.AUTO\n            : SheetSize.AUTO_MARKS;\n        this.bleed = (_c = printOpts.bleed) !== null && _c !== void 0 ? _c : defaultPageSetup.bleed;\n        this.printTwoUp =\n            !!printOpts.layout && printOpts.layout !== SheetLayout.PAGES;\n    }\n    get displaySize() {\n        const width = this.printTwoUp ? this.spreadSize.width : this.size.width;\n        const height = this.size.height;\n        const bleed = this.bleed;\n        return { width, height, bleed };\n    }\n    get sheetSize() {\n        const width = this.printTwoUp ? this.spreadSize.width : this.size.width;\n        const height = this.size.height;\n        const doubleBleed = `2 * ${this.bleed}`;\n        const doubleMarks = `${doubleBleed} + 2 * ${this.markLength}`;\n        const singleMarks = `${this.bleed} + ${this.markLength}`;\n        switch (this.paper) {\n            case SheetSize.AUTO:\n                return { width, height };\n            case SheetSize.AUTO_BLEED:\n                return {\n                    width: `calc(${width} + ${this.printTwoUp ? doubleBleed : this.bleed})`,\n                    height: `calc(${height} + ${doubleBleed})`,\n                };\n            case SheetSize.AUTO_MARKS:\n                return {\n                    width: `calc(${width} + ${this.printTwoUp ? doubleMarks : singleMarks})`,\n                    height: `calc(${height} + ${doubleMarks})`,\n                };\n            case SheetSize.LETTER_LANDSCAPE:\n                return { width: letter.height, height: letter.width };\n            case SheetSize.LETTER_PORTRAIT:\n                return letter;\n            case SheetSize.A4_PORTRAIT:\n                return a4;\n            case SheetSize.A4_LANDSCAPE:\n                return { width: a4.height, height: a4.width };\n            default:\n                throw Error(`Can't get dimensions for unknown paper size: ${this.paper}`);\n        }\n    }\n    get spreadSize() {\n        const w = parseLength(this.size.width);\n        return {\n            height: this.size.height,\n            width: `${w.val * 2}${w.unit}`,\n        };\n    }\n    updateStyleVars() {\n        const page = this.size;\n        const sheet = this.sheetSize;\n        const cssVariables = {\n            'spread-width': this.spreadSize.width,\n            'page-width': page.width,\n            'page-height': page.height,\n            'sheet-width': sheet.width,\n            'sheet-height': sheet.height,\n            'margin-inner': this.margin.inner,\n            'margin-outer': this.margin.outer,\n            'margin-top': this.margin.top,\n            'margin-bottom': this.margin.bottom,\n            bleed: this.bleed,\n            'mark-length': this.markLength,\n        };\n        const cssStr = Object.entries(cssVariables)\n            .map(([k, v]) => {\n            return `--bindery-${k}: ${v};`;\n        })\n            .join('');\n        const rootRule = `:root { ${cssStr} }`;\n        const pageRule = `@page { size: ${sheet.width} ${sheet.height}; }`;\n        stylesheet('binderyPage').innerHTML = `${rootRule} ${pageRule}`;\n    }\n}\nexport default PageSetup;\n","export class Rule {\n    constructor(options) {\n        var _a;\n        this.name = (_a = options.name) !== null && _a !== void 0 ? _a : 'Unnamed Bindery Rule';\n        this.selector = '';\n        Object.keys(options).forEach(key => {\n            this[key] = options[key];\n        });\n    }\n    setup() { }\n}\n","const validateRuntimeOptions = (opts, validOpts) => {\n    if (!validOpts)\n        throw Error('Valid options not specified');\n    Object.keys(opts).forEach(k => {\n        var _a;\n        if (!validOpts[k]) {\n            const setName = (_a = validOpts.name) !== null && _a !== void 0 ? _a : 'This option';\n            throw Error(`Unknown option in ${setName}: '${k}'`);\n        }\n        const val = opts[k];\n        const type = validOpts[k];\n        if (!type.check(val)) {\n            const optName = validOpts.name ? `${validOpts.name}.${k}` : k;\n            const valName = JSON.stringify(val);\n            throw Error(`Invalid value for '${optName}': ${valName} is not a ${type.name}.`);\n        }\n    });\n    return true;\n};\nexport default validateRuntimeOptions;\n","import { isLength } from '../utils';\nimport validateRuntimeOptions from './validateRuntimeOptions';\nconst isObj = (val) => typeof val === 'object';\nconst isFunc = (val) => typeof val === 'function';\nconst isBool = (val) => typeof val === 'boolean';\nconst isStr = (val) => typeof val === 'string';\nconst isNum = (val) => typeof val === 'number';\nconst isArr = (val) => Array.isArray(val);\nconst hasProp = (obj, k) => Object.prototype.hasOwnProperty.call(obj, k);\nconst hasSameKeys = (opts, required) => {\n    const keys = Object.keys(required).filter(k => k !== 'name');\n    return !keys.some(k => !hasProp(opts, k));\n};\nconst isShape = (template) => {\n    return (input) => {\n        return isObj(input) && validateRuntimeOptions(input, template);\n    };\n};\nconst isShapeExact = (template) => {\n    return (input) => {\n        return (isObj(input) &&\n            hasSameKeys(input, template) &&\n            validateRuntimeOptions(input, template));\n    };\n};\nconst isEnum = (cases) => {\n    return (str) => {\n        return cases.includes(str);\n    };\n};\nconst lengthChecker = {\n    name: 'length (string with absolute units)',\n    check: isLength,\n};\nconst RuntimeTypes = {\n    any: {\n        name: 'any',\n        check: () => true,\n    },\n    enum(...cases) {\n        return {\n            name: `(${cases.map(c => `\"${c}\"`).join(' | ')})`,\n            check: isEnum(cases),\n        };\n    },\n    shapeExact: (template) => ({\n        name: `exactly ({${Object.keys(template).join(', ')}})`,\n        check: isShapeExact(template),\n    }),\n    shape: (template) => ({\n        name: `shape ({${Object.keys(template).join(', ')}})`,\n        check: isShape(template),\n    }),\n    string: {\n        name: 'string',\n        check: isStr,\n    },\n    length: lengthChecker,\n    number: {\n        name: 'number',\n        check: isNum,\n    },\n    bool: {\n        name: 'bool',\n        check: isBool,\n    },\n    func: {\n        name: 'func',\n        check: isFunc,\n    },\n    obj: {\n        name: 'object',\n        check: isObj,\n    },\n    array: {\n        name: 'array',\n        check: isArr,\n    },\n    margin: {\n        name: 'margin ({ top, inner, outer, bottom })',\n        check: isShapeExact({\n            name: 'margin',\n            top: lengthChecker,\n            inner: lengthChecker,\n            outer: lengthChecker,\n            bottom: lengthChecker,\n        }),\n    },\n    size: {\n        name: 'size ({ width, height })',\n        check: isShapeExact({\n            name: 'size',\n            width: lengthChecker,\n            height: lengthChecker,\n        }),\n    },\n};\nexport default RuntimeTypes;\n","import { Rule } from './Rule';\nimport { validateRuntimeOptions, RuntimeTypes } from '../runtimeOptionChecker';\nclass Counter extends Rule {\n    constructor(options) {\n        var _a, _b, _c;\n        super(options);\n        this.selector = '*';\n        this.counterValue = 0;\n        this.incrementEl = (_a = options.incrementEl) !== null && _a !== void 0 ? _a : '';\n        this.resetEl = (_b = options.resetEl) !== null && _b !== void 0 ? _b : '';\n        this.replaceEl = (_c = options.replaceEl) !== null && _c !== void 0 ? _c : '';\n        validateRuntimeOptions(options, {\n            name: 'Counter',\n            replaceEl: RuntimeTypes.string,\n            resetEl: RuntimeTypes.string,\n            incrementEl: RuntimeTypes.string,\n            replace: RuntimeTypes.func,\n        });\n    }\n    setup() {\n        this.counterValue = 0;\n    }\n    beforeAdd(el) {\n        if (el.matches(this.incrementEl))\n            this.counterValue += 1;\n        if (el.matches(this.resetEl))\n            this.counterValue = 0;\n        if (el.matches(this.replaceEl))\n            return this.createReplacement(el);\n        return el;\n    }\n    createReplacement(element) {\n        return this.replace(element, this.counterValue);\n    }\n    replace(element, counterValue) {\n        element.textContent = `${counterValue}`;\n        return element;\n    }\n}\nexport default Counter;\n","import { Rule } from './Rule';\nclass OutOfFlow extends Rule {\n    constructor(options) {\n        super(options);\n        this.name = 'Out of Flow';\n    }\n    createOutOfFlowPages(elmt, book, makeNewPage) {\n        throw Error('createOutOfFlowPages must be overridden');\n    }\n    beforeAdd(elmt) {\n        // Avoid breaking inside this element. Once it's completely added,\n        // it will moved onto the background layer.\n        elmt.setAttribute('data-ignore-overflow', 'true');\n        return elmt;\n    }\n    afterAdd(elmt, book, continueOnNewPage, makeNewPage) {\n        this.createOutOfFlowPages(elmt, book, makeNewPage);\n        // Catches cases when we didn't need to create a new page. but unclear\n        if (this.continue !== 'same' || book.currentPage.hasOutOfFlowContent) {\n            continueOnNewPage();\n            if (this.continue === 'left' || this.continue === 'right') {\n                book.currentPage.setPreference(this.continue);\n            }\n        }\n        return elmt;\n    }\n}\nexport default OutOfFlow;\n","import OutOfFlow from './OutOfFlow';\nimport { validateRuntimeOptions, RuntimeTypes } from '../runtimeOptionChecker';\nimport { prefixer, div } from '../dom';\n// Options:\n// selector: String\nclass FullBleedSpread extends OutOfFlow {\n    constructor(options) {\n        var _a, _b;\n        options.continue = (_a = options.continue) !== null && _a !== void 0 ? _a : 'same';\n        options.rotate = (_b = options.rotate) !== null && _b !== void 0 ? _b : 'none';\n        super(options);\n        validateRuntimeOptions(options, {\n            name: 'FullBleedSpread',\n            selector: RuntimeTypes.string,\n            continue: RuntimeTypes.enum('next', 'same', 'left', 'right'),\n            rotate: RuntimeTypes.enum('none', 'clockwise', 'counterclockwise'),\n        });\n    }\n    createOutOfFlowPages(elmt, book, makeNewPage) {\n        if (!!elmt.parentNode) {\n            elmt.parentNode.removeChild(elmt);\n        }\n        let leftPage;\n        if (book.currentPage.isEmpty) {\n            leftPage = book.currentPage;\n        }\n        else {\n            leftPage = makeNewPage();\n            book.addPage(leftPage);\n        }\n        const rightPage = makeNewPage();\n        book.addPage(rightPage);\n        if (this.rotate !== 'none') {\n            [leftPage, rightPage].forEach(page => {\n                const rotateContainer = div(`.rotate-container.spread-size-rotated.rotate-spread-${this.rotate}`);\n                rotateContainer.append(page.background);\n                page.element.append(rotateContainer);\n            });\n        }\n        leftPage.background.append(elmt);\n        leftPage.element.classList.add(prefixer('spread'));\n        leftPage.setPreference('left');\n        leftPage.isOutOfFlow = this.continue === 'same';\n        leftPage.avoidReorder = true;\n        leftPage.hasOutOfFlowContent = true;\n        rightPage.background.append(elmt.cloneNode(true));\n        rightPage.element.classList.add(prefixer('spread'));\n        rightPage.setPreference('right');\n        rightPage.isOutOfFlow = this.continue === 'same';\n        rightPage.avoidReorder = true;\n        rightPage.hasOutOfFlowContent = true;\n    }\n}\nexport default FullBleedSpread;\n","import OutOfFlow from './OutOfFlow';\nimport { validateRuntimeOptions, RuntimeTypes } from '../runtimeOptionChecker';\nimport { div } from '../dom';\n// Options:\n// selector: String\nclass FullBleedPage extends OutOfFlow {\n    constructor(options) {\n        var _a, _b;\n        options.continue = (_a = options.continue) !== null && _a !== void 0 ? _a : 'same';\n        options.rotate = (_b = options.rotate) !== null && _b !== void 0 ? _b : 'none';\n        super(options);\n        validateRuntimeOptions(options, {\n            name: 'FullBleedPage',\n            selector: RuntimeTypes.string,\n            continue: RuntimeTypes.enum('next', 'same', 'left', 'right'),\n            rotate: RuntimeTypes.enum('none', 'inward', 'outward', 'clockwise', 'counterclockwise'),\n        });\n    }\n    createOutOfFlowPages(elmt, book, makeNewPage) {\n        if (elmt.parentNode) {\n            elmt.parentNode.removeChild(elmt);\n        }\n        let newPage;\n        if (book.currentPage.isEmpty) {\n            newPage = book.currentPage;\n        }\n        else {\n            newPage = makeNewPage();\n            book.addPage(newPage);\n        }\n        if (this.rotate !== 'none') {\n            const rotateContainer = div(`.rotate-container.page-size-rotated.rotate-${this.rotate}`);\n            rotateContainer.appendChild(newPage.background);\n            newPage.element.appendChild(rotateContainer);\n        }\n        newPage.background.appendChild(elmt);\n        newPage.hasOutOfFlowContent = true;\n    }\n}\nexport default FullBleedPage;\n","import { Rule } from './Rule';\n// Options:\n// selector: String\n// replace: function (HTMLElement) => HTMLElement\nclass Replace extends Rule {\n    constructor(options) {\n        super(options);\n        this.name = 'Replace';\n    }\n    afterAdd(element, book, continueOnNewPage, makeNewPage, overflowCallback) {\n        const parent = element.parentNode;\n        if (!parent) {\n            console.error(element);\n            throw Error(`Bindery.Replace({ selector: '${this.selector}' }).afterAdd called on element that hasn't been added.`);\n        }\n        const defensiveClone = element.cloneNode(true);\n        const replacement = this.createReplacement(book, defensiveClone);\n        parent.replaceChild(replacement, element);\n        if (book.currentPage.hasOverflowed()) {\n            parent.replaceChild(element, replacement);\n            return overflowCallback(element);\n        }\n        return replacement;\n    }\n    createReplacement(book, element) {\n        return this.replace(element);\n    }\n    replace(element, info) {\n        element.insertAdjacentHTML('beforeend', '<sup class=\"bindery-sup\">Default Replacement</sup>');\n        return element;\n    }\n}\nexport default Replace;\n","import Replace from './Replace';\nimport { validateRuntimeOptions, RuntimeTypes } from '../runtimeOptionChecker';\nimport { div } from '../dom';\n// Options:\n// selector: String\n// replace: function (HTMLElement, number) => HTMLElement\n// render: function (Page) => HTMLElement\nclass Footnote extends Replace {\n    constructor(options) {\n        super(options);\n        validateRuntimeOptions(options, {\n            name: 'Footnote',\n            selector: RuntimeTypes.string,\n            replace: RuntimeTypes.func,\n            render: RuntimeTypes.func,\n        });\n    }\n    afterAdd(element, book, continueOnNewPage, makeNewPage, overflowCallback) {\n        const number = book.currentPage.footer.children.length + 1;\n        const footnote = div('.footnote');\n        const contents = this.render(element, number);\n        if (contents instanceof HTMLElement)\n            footnote.appendChild(contents);\n        else\n            footnote.innerHTML = contents;\n        book.currentPage.footer.appendChild(footnote);\n        return super.afterAdd(element, book, continueOnNewPage, makeNewPage, (overflowEl) => {\n            book.currentPage.footer.removeChild(footnote);\n            return overflowCallback(overflowEl);\n        });\n    }\n    createReplacement(book, element) {\n        const number = book.currentPage.footer.children.length;\n        return this.replace(element, number);\n    }\n    replace(element, number) {\n        element.insertAdjacentHTML('beforeend', `<sup class=\"bindery-sup\">${number}</sup>`);\n        return element;\n    }\n    render(element, number) {\n        return `<sup>${number}</sup> Default footnote (<a href='/bindery/docs/#footnote'>Learn how to change it</a>)`;\n    }\n}\nexport default Footnote;\n","/* ðŸ“– Regionize v0.1.6 */\nconst div = (cls) => {\n    const el = document.createElement('div');\n    el.classList.add(cls);\n    return el;\n};\nclass Region {\n    constructor(el) {\n        this.suppressErrors = false;\n        this.element = el;\n        this.content = div('region-content');\n        this.content.style.position = 'relative';\n        this.element.appendChild(this.content);\n        this.path = [];\n    }\n    setPath(newPath) {\n        this.path = newPath;\n        if (newPath.length > 0)\n            this.content.appendChild(newPath[0]);\n    }\n    get currentElement() {\n        const len = this.path.length;\n        if (len > 0)\n            return this.path[len - 1];\n        return this.content;\n    }\n    isEmpty() {\n        const el = this.content;\n        if (el.textContent === null)\n            return true;\n        return el.textContent.trim() === '' && el.offsetHeight < 2;\n    }\n    isReasonableSize() {\n        const box = this.element.getBoundingClientRect();\n        return box.height > 100 && box.width > 100; // TODO: Number is arbitrary\n    }\n    overflowAmount() {\n        const contentH = this.content.offsetHeight;\n        const boxH = this.element.offsetHeight;\n        if (boxH === 0)\n            throw Error('Regionizer: Trying to flow into an element with zero height.');\n        return contentH - boxH;\n    }\n    hasOverflowed() {\n        return this.overflowAmount() > -5;\n    }\n}\n\nconst isTextNode = (node) => {\n    return node.nodeType === Node.TEXT_NODE;\n};\nconst isElement = (node) => {\n    return node.nodeType === Node.ELEMENT_NODE;\n};\nconst isScript = (node) => {\n    return node.tagName === 'SCRIPT';\n};\nconst isImage = (node) => {\n    return node.tagName === 'IMG';\n};\nconst isUnloadedImage = (node) => {\n    return isImage(node) && !node.naturalWidth;\n};\nconst isContentElement = (node) => {\n    return isElement(node) && !isScript(node);\n};\n\nconst MAX_TIME = 30; // ms\nconst rAF = () => new Promise(resolve => {\n    requestAnimationFrame(t => resolve(t));\n});\nlet lastYieldTime = 0;\nconst shouldYield = () => {\n    const timeSinceYield = performance.now() - lastYieldTime;\n    return timeSinceYield > MAX_TIME;\n};\nconst yieldIfNecessary = async () => {\n    if (shouldYield())\n        lastYieldTime = await rAF();\n};\n\nconst overflowAttr = 'data-ignore-overflow';\n// Walk up the tree to see if we are within\n// an overflow-ignoring node\nconst ignoreOverflow = (element) => {\n    if (element.hasAttribute(overflowAttr))\n        return true;\n    if (element.parentElement)\n        return ignoreOverflow(element.parentElement);\n    return false;\n};\n\nconst SPACE = ' ';\nconst nextWordEnd = (text, startIndex) => {\n    let newIndex = startIndex + 1;\n    while (newIndex < text.length && text.charAt(newIndex) !== SPACE) {\n        newIndex += 1;\n    }\n    return newIndex;\n};\nconst previousWordEnd = (text, startIndex) => {\n    let newIndex = startIndex;\n    if (text.charAt(newIndex) === SPACE) {\n        newIndex -= 1;\n    }\n    while (text.charAt(newIndex) !== SPACE && newIndex > 0) {\n        newIndex -= 1;\n    }\n    return newIndex;\n};\n\nconst createTextNode = document.createTextNode.bind(document);\n// Try adding a text node in one go.\n// Returns true if all the text fits, false if none fits.\nconst addInOneGo = async (textNode, container, hasOverflowed) => {\n    container.appendChild(textNode);\n    const success = !hasOverflowed();\n    if (!success)\n        container.removeChild(textNode);\n    await yieldIfNecessary();\n    return { completed: success };\n};\n// Incrementally add words to the container until it just barely doesnt\n// overflow. Returns a remainder textNode for remaining text.\nconst fillWordsUntilOverflow = async (textNode, container, hasOverflowed) => {\n    const originalText = textNode.nodeValue || '';\n    container.appendChild(textNode);\n    if (!hasOverflowed() || ignoreOverflow(container)) {\n        // The whole thing fits\n        return { completed: true };\n    }\n    // Clear the node\n    let proposedEnd = 0;\n    textNode.nodeValue = originalText.substr(0, proposedEnd);\n    while (!hasOverflowed() && proposedEnd < originalText.length) {\n        // Reveal the next word\n        proposedEnd = nextWordEnd(originalText, proposedEnd);\n        if (proposedEnd < originalText.length) {\n            textNode.nodeValue = originalText.substr(0, proposedEnd);\n            await yieldIfNecessary();\n        }\n    }\n    // Back out to word boundary\n    const wordEnd = previousWordEnd(originalText, proposedEnd);\n    if (wordEnd < 1) {\n        // We didn't even add a complete word, don't add node\n        textNode.nodeValue = originalText;\n        container.removeChild(textNode);\n        return { completed: false };\n    }\n    // trim text to word\n    const fittingText = originalText.substr(0, wordEnd);\n    const overflowingText = originalText.substr(wordEnd);\n    textNode.nodeValue = fittingText;\n    // Create a new text node for the next flow box\n    return {\n        completed: true,\n        remainder: createTextNode(overflowingText),\n    };\n};\n// Fills text across multiple elements by requesting a continuation\n// once the current element overflows\nconst fillWords = async (textNode, container, getNextContainer, hasOverflowed) => {\n    const textLayout = await fillWordsUntilOverflow(textNode, container, hasOverflowed);\n    if (textLayout.remainder) {\n        const nextContainer = getNextContainer();\n        return fillWords(textLayout.remainder, nextContainer, getNextContainer, hasOverflowed);\n    }\n    return textLayout;\n};\n\n// Shifts this element to the next page. If any of its\n// ancestors cannot be split across page, it will\n// step up the tree to find the first ancestor\n// that can be split, and move all of that descendants\n// to the next page.\nconst tryInNextRegion = (region, makeNextRegion, canSplit) => {\n    if (region.path.length <= 1) {\n        throw Error('Regionize: Attempting to move the top-level element');\n    }\n    const startLength = region.path.length;\n    // So this node won't get cloned. TODO: this is unclear\n    const elementToMove = region.path.pop();\n    // find the nearest splittable parent\n    let nearestMoveableElement = elementToMove;\n    const pathToRestore = [];\n    while (region.path.length > 1 && !canSplit(region.currentElement)) {\n        nearestMoveableElement = region.path.pop();\n        pathToRestore.unshift(nearestMoveableElement);\n    }\n    // Once a node is moved to a new page, it should no longer trigger another\n    // move. otherwise tall elements will endlessly get shifted to the next page\n    nearestMoveableElement.setAttribute('data-regionize-did-move', 'true');\n    const parent = nearestMoveableElement.parentNode;\n    parent.removeChild(nearestMoveableElement);\n    // If the nearest ancestor would be empty without this node,\n    // move it to the next page too.\n    if (region.path.length > 1 &&\n        region.currentElement.textContent.trim() === '') {\n        parent.appendChild(nearestMoveableElement);\n        nearestMoveableElement = region.path.pop();\n        pathToRestore.unshift(nearestMoveableElement);\n        nearestMoveableElement.parentNode.removeChild(nearestMoveableElement);\n    }\n    let nextRegion;\n    if (!region.isEmpty()) {\n        if (region.hasOverflowed()) {\n            // Recovery failed, maybe the box contains a large\n            // unsplittable element.\n            region.suppressErrors = true;\n        }\n        nextRegion = makeNextRegion();\n    }\n    else {\n        // If the page is empty when this node is removed,\n        // then it won't help to move it to the next page.\n        // Instead continue here until the node is done.\n        nextRegion = region;\n    }\n    // append moved node as first in new page\n    nextRegion.currentElement.appendChild(nearestMoveableElement);\n    // restore subpath\n    pathToRestore.forEach(r => nextRegion.path.push(r));\n    nextRegion.path.push(elementToMove);\n    if (startLength !== nextRegion.path.length) {\n        throw Error('Regionize: Restored path depth does not match original path depth');\n    }\n};\n\n// The path is an array of nested elments,\n// for example .content > article > p > a).\n//\n// It's shallowly cloned every time we move to the next page,\n// to create the illusion that nodes are continuing from page\n// to page.\n//\n// The transition can be customized by setting a Split rule,\n// which lets you add classes to the original and cloned element\n// to customize styling.\nconst clone = (el, withChildren) => {\n    return el.cloneNode(withChildren);\n};\nconst shallowClone = (el) => clone(el, false);\nconst deepClone = (el) => clone(el, true);\nconst clonePath = (oldPath, applyRules) => {\n    const newPath = [];\n    const deepCloneWithRules = (el) => {\n        const clone = deepClone(el); // could be th > h3 > span;\n        applyRules(el, clone);\n        return clone;\n    };\n    for (let i = oldPath.length - 1; i >= 0; i -= 1) {\n        const original = oldPath[i];\n        const clone = shallowClone(original);\n        const nextChild = oldPath[i + 1];\n        clone.innerHTML = '';\n        applyRules(original, clone, nextChild, deepCloneWithRules);\n        if (i < oldPath.length - 1)\n            clone.appendChild(newPath[i + 1]);\n        newPath[i] = clone;\n    }\n    return newPath;\n};\n\n// Polls every 10ms for image.naturalWidth\n// or an error event.\n//\n// Note: Doesn't ever reject, since missing images\n// shouldn't prevent layout from resolving\nconst wait10 = () => new Promise(resolve => {\n    setTimeout(() => {\n        resolve();\n    }, 10);\n});\nconst ensureImageLoaded = async (image) => {\n    const imgStart = performance.now();\n    let failed = false;\n    image.addEventListener('error', () => {\n        failed = true;\n    });\n    image.src = image.src; // re-trigger error if already failed\n    while (!image.naturalWidth && !failed) {\n        await wait10();\n    }\n    return performance.now() - imgStart;\n};\n\nconst preserveNumbering = (original, clone, nextChild) => {\n    // restart numbering\n    let prevStart = 1;\n    if (original.hasAttribute('start')) {\n        // the OL is also a continuation\n        prevStart = parseInt(original.getAttribute('start') || '', 10);\n    }\n    if (nextChild && nextChild.tagName === 'LI') {\n        // the first list item is a continuation\n        prevStart -= 1;\n    }\n    const prevCount = original.children.length;\n    const newStart = prevStart + prevCount;\n    clone.setAttribute('start', `${newStart}`);\n};\n\nconst preserveTableColumns = (original, clone, nextChild, deepClone) => {\n    const columns = [...original.children];\n    const currentIndex = columns.indexOf(nextChild);\n    for (let i = 0; i < currentIndex; i += 1) {\n        const origCol = columns[i];\n        if (origCol) {\n            const clonedCol = deepClone(origCol);\n            clone.appendChild(clonedCol);\n        }\n    }\n};\n\nconst noop = () => { };\nconst always = () => true;\nconst never = () => false;\n// flow content through FlowBoxes.\n// the caller is responsible for managing\n// and creating regions.\nconst flowIntoRegions = async (opts) => {\n    var _a, _b, _c, _d, _e, _f;\n    const content = opts.content;\n    const createRegion = opts.createRegion;\n    if (!content)\n        throw Error('content not specified');\n    if (!createRegion)\n        throw Error('createRegion not specified');\n    // optional\n    const applySplit = (_a = opts.applySplit) !== null && _a !== void 0 ? _a : noop;\n    const canSplit = (_b = opts.canSplit) !== null && _b !== void 0 ? _b : always;\n    const beforeAdd = (_c = opts.beforeAdd) !== null && _c !== void 0 ? _c : noop;\n    const afterAdd = (_d = opts.afterAdd) !== null && _d !== void 0 ? _d : noop;\n    const didWaitFor = (_e = opts.didWaitFor) !== null && _e !== void 0 ? _e : noop;\n    const shouldTraverse = (_f = opts.shouldTraverse) !== null && _f !== void 0 ? _f : never;\n    // currentRegion should hold the only state that persists during traversal.\n    let currentRegion = createRegion();\n    const hasOverflowed = () => currentRegion.hasOverflowed();\n    const canSplitCurrent = () => canSplit(currentRegion.currentElement);\n    const ignoreCurrentOverflow = () => ignoreOverflow(currentRegion.currentElement);\n    const splitRules = (original, clone, nextChild, deepClone) => {\n        if (original.tagName === 'OL') {\n            preserveNumbering(original, clone, nextChild);\n        }\n        if (original.tagName === 'TR' && nextChild && deepClone) {\n            preserveTableColumns(original, clone, nextChild, deepClone);\n        }\n        applySplit(original, clone, nextChild, deepClone);\n    };\n    const continueInNextRegion = () => {\n        const prevRegion = currentRegion;\n        currentRegion = createRegion();\n        const newPath = clonePath(prevRegion.path, splitRules);\n        currentRegion.setPath(newPath);\n        return currentRegion;\n    };\n    const continuedParent = () => {\n        continueInNextRegion();\n        return currentRegion.currentElement;\n    };\n    const addText = async (textNode, isSplittable) => {\n        const el = currentRegion.currentElement;\n        let textLayout;\n        if (isSplittable) {\n            // Add the text word by word, adding pages as needed\n            textLayout = await fillWords(textNode, el, continuedParent, hasOverflowed);\n            if (!textLayout.completed && currentRegion.path.length > 1) {\n                tryInNextRegion(currentRegion, continueInNextRegion, canSplit);\n                textLayout = await fillWords(textNode, el, continuedParent, hasOverflowed);\n            }\n        }\n        else {\n            // Add the text as a block, trying a new page if needed\n            textLayout = await addInOneGo(textNode, currentRegion.currentElement, hasOverflowed);\n            if (!textLayout.completed && !ignoreCurrentOverflow()) {\n                tryInNextRegion(currentRegion, continueInNextRegion, canSplit);\n                textLayout = await addInOneGo(textNode, currentRegion.currentElement, hasOverflowed);\n            }\n        }\n        // Something went wrong. Insert the text anyways, ignoring overflow,\n        // and move onto the next region.\n        if (!textLayout.completed) {\n            currentRegion.currentElement.appendChild(textNode);\n            if (!ignoreCurrentOverflow() && canSplitCurrent()) {\n                currentRegion.suppressErrors = true;\n                continueInNextRegion();\n            }\n        }\n    };\n    const shouldTraverseChildren = (element) => {\n        if (hasOverflowed())\n            return true;\n        if (element.querySelector('img'))\n            return true;\n        if (shouldTraverse(element))\n            return true;\n        return false;\n    };\n    const addElement = async (element) => {\n        // Ensure images are loaded before testing for overflow\n        if (isUnloadedImage(element)) {\n            const waitTime = await ensureImageLoaded(element);\n            didWaitFor(waitTime);\n        }\n        // Transforms before adding\n        await beforeAdd(element, continueInNextRegion);\n        // Append element and push onto the the stack\n        currentRegion.currentElement.appendChild(element);\n        currentRegion.path.push(element);\n        if (shouldTraverseChildren(element)) {\n            // Only if the region overflowed, the content contains\n            // an image, or the caller has requested a custom traversal.\n            await clearAndAddChildren(element);\n        }\n        // We're done: Pop off the stack and do any cleanup\n        const addedElement = currentRegion.path.pop();\n        await afterAdd(addedElement, continueInNextRegion);\n    };\n    const clearAndAddChildren = async (element) => {\n        const childNodes = [...element.childNodes];\n        element.innerHTML = '';\n        if (hasOverflowed() && !ignoreCurrentOverflow() && canSplitCurrent()) {\n            // Overflows when empty\n            tryInNextRegion(currentRegion, continueInNextRegion, canSplit);\n        }\n        const shouldSplit = canSplit(element) && !ignoreOverflow(element);\n        for (const child of childNodes) {\n            if (isTextNode(child)) {\n                await addText(child, shouldSplit);\n            }\n            else if (isContentElement(child)) {\n                await addElement(child);\n            }\n        }\n    };\n    return addElement(content);\n};\n\nexport { Region, flowIntoRegions };\n","import { Region } from 'regionize';\nimport { safeMeasure, div, classes } from '../dom';\nclass HierarchyToHeadingAdapter {\n    constructor(getter) {\n        // console.warn('Deprecated');\n        this.getHierarchy = getter;\n    }\n    textFor(sel) {\n        var _a, _b;\n        return (_b = (_a = this.getHierarchy()) === null || _a === void 0 ? void 0 : _a.find(entry => (entry === null || entry === void 0 ? void 0 : entry.selector) === sel)) === null || _b === void 0 ? void 0 : _b.text;\n    }\n    get h1() {\n        return this.textFor('h1');\n    }\n    get h2() {\n        return this.textFor('h2');\n    }\n    get h3() {\n        return this.textFor('h3');\n    }\n    get h4() {\n        return this.textFor('h4');\n    }\n    get h5() {\n        return this.textFor('h5');\n    }\n    get h6() {\n        return this.textFor('h6');\n    }\n}\nclass Page {\n    constructor() {\n        this.hierarchy = [];\n        this.suppress = false;\n        this.hasOutOfFlowContent = false;\n        this.alwaysLeft = false;\n        this.alwaysRight = false;\n        this.isOutOfFlow = false; // used by spreads\n        this.avoidReorder = false; // used by 2-page spreads\n        this.flow = new Region(div('flow-box'));\n        this.footer = div('footer');\n        this.background = div('page-background');\n        this.element = div('page', this.background, this.flow.element, this.footer);\n        this.heading = new HierarchyToHeadingAdapter(() => this.hierarchy);\n    }\n    static isSizeValid() {\n        const testPage = new Page();\n        return safeMeasure(testPage.element, () => testPage.flow.isReasonableSize);\n    }\n    setLeftRight(dir) {\n        this.side = dir;\n        this.element.classList.toggle(classes.leftPage, this.isLeft);\n        this.element.classList.toggle(classes.rightPage, !this.isLeft);\n    }\n    get isLeft() {\n        return this.side === 'left';\n    }\n    get isRight() {\n        return this.side === 'right';\n    }\n    setPreference(dir) {\n        const preferLeft = dir === 'left';\n        this.alwaysLeft = preferLeft;\n        this.alwaysRight = !preferLeft;\n    }\n    get suppressErrors() {\n        var _a;\n        return (_a = this.suppress) !== null && _a !== void 0 ? _a : false;\n    }\n    set suppressErrors(newVal) {\n        this.suppress = newVal;\n        this.element.classList.toggle(classes.isOverflowing, newVal);\n    }\n    get isEmpty() {\n        return !this.hasOutOfFlowContent && this.flow.isEmpty();\n    }\n    validate() {\n        if (!this.hasOverflowed())\n            return;\n        const suspect = this.flow.currentElement;\n        if (suspect) {\n            console.warn('Bindery: Content overflows, probably due to a style set on:', suspect);\n            if (suspect.parentNode) {\n                suspect.parentNode.removeChild(suspect);\n            }\n        }\n        else {\n            console.warn('Bindery: Content overflows.');\n        }\n    }\n    validateEnd(allowOverflow) {\n        if (!this.hasOverflowed())\n            return;\n        console.warn(`Bindery: Page ~${this.number} is overflowing`, this.element);\n        if (!this.suppressErrors && !this.flow.suppressErrors && !allowOverflow) {\n            throw Error('Bindery: Moved to new page when last one is still overflowing');\n        }\n    }\n    hasOverflowed() {\n        return safeMeasure(this.element, () => this.flow.hasOverflowed());\n    }\n}\nexport default Page;\n","const indexOfNextReorderablePage = (pages, startIndex) => {\n    for (let i = startIndex; i < pages.length; i += 1) {\n        const pg = pages[i];\n        if (!pg.isOutOfFlow && !pg.avoidReorder)\n            return i;\n    }\n    return null;\n};\n// Given an array of pages with alwaysLeft, alwaysRight, and isOutOfFlow\n// properties, orders them so that alwaysLeft and alwaysRight are true.\nconst orderPages = (pages, makeNewPage) => {\n    const orderedPages = pages.slice();\n    for (let i = 0; i < orderedPages.length; i += 1) {\n        const page = orderedPages[i];\n        const isLeft = i % 2 !== 0;\n        if ((isLeft && page.alwaysRight) || (!isLeft && page.alwaysLeft)) {\n            if (page.isOutOfFlow) {\n                // If the page is 'out of flow', we'd prefer not to add a blank page.\n                // Instead it floats backwards in the book, pulling the next\n                // in-flow page forward. If several 'out of flow' pages\n                // are next to each other, they will remain in order, all being pushed\n                // backward together.\n                const indexToSwap = indexOfNextReorderablePage(orderedPages, i + 1);\n                if (!indexToSwap) {\n                    // No larger index to swap with, perhaps because\n                    // we are optimistically rendering before the book is done\n                    break;\n                }\n                const pageToMoveUp = orderedPages[indexToSwap];\n                orderedPages.splice(indexToSwap, 1); // remove pg\n                orderedPages.splice(i, 0, pageToMoveUp); // insert pg\n            }\n            else {\n                // If the page is 'in flow', order must be respected, so extra blank pages\n                // are inserted.\n                orderedPages.splice(i, 0, makeNewPage());\n            }\n        }\n    }\n    return orderedPages;\n};\nexport default orderPages;\n","import Page from './Page';\nimport orderPages from './orderPages';\nconst MAXIMUM_PAGE_LIMIT = 2000;\nclass Book {\n    constructor() {\n        this.rawPages = [];\n        this.orderedPages = [];\n    }\n    addPage(newPage) {\n        this.rawPages.push(newPage);\n        this.updatePageOrder();\n    }\n    get pageCount() {\n        return this.orderedPages.length;\n    }\n    get pages() {\n        return this.orderedPages;\n    }\n    updatePageOrder() {\n        this.orderedPages = orderPages(this.rawPages, () => new Page());\n    }\n    validate() {\n        if (this.pageCount > MAXIMUM_PAGE_LIMIT) {\n            throw Error('Bindery: Maximum page count exceeded. Suspected runaway layout.');\n        }\n    }\n}\nexport default Book;\n","export const annotatePagesNumbers = (pages, offset) => {\n    // â€”â€”â€”\n    // NUMBERING\n    // TODO: Pass in facingpages as an option?\n    const facingPages = true;\n    if (facingPages) {\n        pages.forEach((page, i) => {\n            page.number = offset + i + 1;\n            page.setLeftRight(i % 2 === 0 ? 'right' : 'left');\n        });\n    }\n    else {\n        pages.forEach(page => {\n            page.setLeftRight('right');\n        });\n    }\n};\nexport const annotatePagesHierarchy = (pages, headerSelectorHierarchy) => {\n    // â€”â€”â€”\n    // RUNNING HEADERS\n    // Sections to annotate with.\n    // This should be a hierarchical list of selectors.\n    // Every time one is selected, it annotates all following pages\n    // and clears any subselectors.\n    let currentHierarchy = [];\n    pages.forEach(page => {\n        const pageHierarchy = [];\n        headerSelectorHierarchy.forEach((selector, i) => {\n            var _a;\n            const element = page.element.querySelector(selector);\n            // A new header level starts on this page\n            if (element) {\n                currentHierarchy[i] = {\n                    selector: selector,\n                    text: (_a = element.textContent) !== null && _a !== void 0 ? _a : '',\n                    el: element,\n                };\n                // Clear any lower headers in the hierarchy\n                currentHierarchy = currentHierarchy.slice(0, i + 1);\n                // headerSelectorHierarchy.forEach((lowerSelector, j) => {\n                //   if (j > i) {\n                //     currentHeaders[j] = { selector: lowerSelector, text: '', el: undefined };\n                //   }\n                // });\n            }\n            // Always decorate this page with current header state.\n            if (currentHierarchy[i]) {\n                pageHierarchy[i] = currentHierarchy[i];\n            }\n        });\n        page.hierarchy = pageHierarchy;\n    });\n};\nexport const annotatePages = (pages, offset) => {\n    annotatePagesNumbers(pages, offset);\n    annotatePagesHierarchy(pages, ['h1', 'h2', 'h3', 'h4', 'h5', 'h6']);\n};\n","const pageNumbersForTest = (pages, test) => {\n    return pages\n        .filter(pg => !!pg.number)\n        .filter(pg => test(pg.element))\n        .map(pg => pg.number);\n};\nconst pageNumbersForSelector = (pages, selector) => {\n    return pageNumbersForTest(pages, (el) => {\n        return !!el.querySelector(selector);\n    });\n};\nexport { pageNumbersForTest, pageNumbersForSelector };\n","import Replace from './Replace';\nimport { formatAsRanges } from '../utils';\nimport { pageNumbersForTest } from '../book';\nimport { shallowEqual, throttleTime } from '../utils';\nimport { validateRuntimeOptions, RuntimeTypes } from '../runtimeOptionChecker';\nimport { prefixer } from '../dom';\n// Compatible with ids that start with numbers\nconst startsWithNumber = (sel) => {\n    return sel.length > 2 && sel[0] === '#' && /^\\d+$/.test(sel[1]);\n};\nconst safeIDSel = (sel) => {\n    return startsWithNumber(sel) ? `[id=\"${sel.replace('#', '')}\"]` : sel;\n};\n// Options:\n// selector: String\n// replace: function (HTMLElement, number) => HTMLElement\nclass PageReference extends Replace {\n    constructor(options) {\n        super(options);\n        validateRuntimeOptions(options, {\n            name: 'PageReference',\n            selector: RuntimeTypes.string,\n            replace: RuntimeTypes.func,\n            createTest: RuntimeTypes.func,\n        });\n        this.references = [];\n        const throttle = throttleTime(10);\n        this.throttledUpdate = book => {\n            throttle(() => this.updatePageReferences(book.pages));\n        };\n    }\n    eachPage(page, book) {\n        this.throttledUpdate(book);\n    }\n    afterAdd(elmt, book) {\n        const test = this.createTest(elmt);\n        if (!test)\n            return elmt;\n        const ref = this.createReference(book, test, elmt);\n        return ref.element;\n    }\n    createReference(book, test, elmt) {\n        const ref = {\n            test,\n            template: elmt,\n            element: elmt,\n            value: null,\n        };\n        this.references.push(ref);\n        const currentResults = pageNumbersForTest(book.pages, test);\n        this.render(ref, currentResults); // Replace element immediately, to make sure it'll fit\n        return ref;\n    }\n    render(ref, newValue) {\n        if (!newValue || shallowEqual(ref.value, newValue))\n            return;\n        if (!Array.isArray(newValue))\n            throw Error('Page search returned unexpected result');\n        const isResolved = newValue.length > 0;\n        const pageRanges = isResolved ? formatAsRanges(newValue) : 'âŒ§';\n        const template = ref.template.cloneNode(true);\n        const newRender = this.replace(template, pageRanges);\n        if (!isResolved)\n            newRender.classList.add(prefixer('placeholder-num'));\n        ref.element.parentNode.replaceChild(newRender, ref.element);\n        ref.element = newRender;\n        ref.value = newValue;\n    }\n    createTest(element) {\n        const href = element.getAttribute('href');\n        if (!href)\n            return null;\n        const selector = safeIDSel(href);\n        return (el) => {\n            return !!el.querySelector(selector);\n        };\n    }\n    updatePageReferences(pages) {\n        // querySelector first, then rerender\n        const results = this.references.map(ref => {\n            return { ref, data: pageNumbersForTest(pages, ref.test) };\n        });\n        results.forEach(({ ref, data }) => this.render(ref, data));\n    }\n    replace(template, number) {\n        template.insertAdjacentHTML('beforeend', `, <span>${number}</span>`);\n        return template;\n    }\n}\nexport default PageReference;\n","// https://github.com/moroshko/shallow-equal/blob/master/src/arrays.js\nconst shallowEqual = (a, b) => {\n    if (a === b)\n        return true;\n    if (!a || !b)\n        return false;\n    const len = a.length;\n    if (b.length !== len) {\n        return false;\n    }\n    for (let i = 0; i < len; i += 1) {\n        if (a[i] !== b[i])\n            return false;\n    }\n    return true;\n};\nexport default shallowEqual;\n","import { Rule } from './Rule';\nimport { validateRuntimeOptions, RuntimeTypes } from '../runtimeOptionChecker';\nclass PageBreak extends Rule {\n    constructor(options) {\n        var _a, _b;\n        super(options);\n        if (options.continue == 'same') {\n            throw Error(\"Can't continue on the same pager after a Page Break \");\n        }\n        this.continue = (_a = options.continue) !== null && _a !== void 0 ? _a : 'next';\n        this.position = (_b = options.position) !== null && _b !== void 0 ? _b : 'before';\n        validateRuntimeOptions(options, {\n            name: 'PageBreak',\n            selector: RuntimeTypes.string,\n            continue: RuntimeTypes.enum('next', 'left', 'right'),\n            position: RuntimeTypes.enum('before', 'after', 'both', 'avoid'),\n        });\n    }\n    get avoidSplit() {\n        return this.position === 'avoid';\n    }\n    beforeAdd(elmt, book, continueOnNewPage) {\n        if (this.position === 'before' || this.position === 'both') {\n            if (!book.currentPage.isEmpty) {\n                continueOnNewPage();\n            }\n            if (this.continue !== 'next') {\n                book.currentPage.setPreference(this.continue);\n            }\n        }\n        return elmt;\n    }\n    afterAdd(elmt, book, continueOnNewPage) {\n        if (this.position === 'after' || this.position === 'both') {\n            continueOnNewPage();\n            if (this.continue !== 'next') {\n                book.currentPage.setPreference(this.continue);\n            }\n        }\n        return elmt;\n    }\n}\nexport default PageBreak;\n","import { Rule } from './Rule';\nimport { validateRuntimeOptions, RuntimeTypes } from '../runtimeOptionChecker';\nimport { div } from '../dom';\n// Options:\n// selector: String\n// render: function (Page) => HTMLElement\n// TODO selectorHierarchy: [ String ], ie [ 'h1', 'h2', 'h3.chapter' ]\nclass RunningHeader extends Rule {\n    constructor(options = {}) {\n        super(options);\n        validateRuntimeOptions(options, {\n            name: 'RunningHeader',\n            render: RuntimeTypes.func,\n        });\n    }\n    eachPage(page) {\n        if (!page.runningHeader) {\n            const elmt = div('.running-header');\n            page.element.appendChild(elmt);\n            page.runningHeader = elmt;\n        }\n        page.runningHeader.innerHTML = this.render(page);\n    }\n    render(page) {\n        return `${page.number}`;\n    }\n}\nexport default RunningHeader;\n","import { Rule } from './Rule';\nimport { validateRuntimeOptions, RuntimeTypes } from '../runtimeOptionChecker';\nclass Split extends Rule {\n    constructor(options) {\n        super(options);\n        this.toNext = options.toNext;\n        this.fromPrevious = options.fromPrevious;\n        validateRuntimeOptions(options, {\n            name: 'Split',\n            selector: RuntimeTypes.string,\n            toNext: RuntimeTypes.string,\n            fromPrevious: RuntimeTypes.string,\n            didSplit: RuntimeTypes.func,\n        });\n    }\n    didSplit(original, clone) {\n        if (this.toNext)\n            original.classList.add(this.toNext);\n        if (this.fromPrevious)\n            clone.classList.add(this.fromPrevious);\n    }\n}\nexport default Split;\n","import Counter from './Counter';\nimport FullBleedSpread from './FullBleedSpread';\nimport FullBleedPage from './FullBleedPage';\nimport Footnote from './Footnote';\nimport PageReference from './PageReference';\nimport PageBreak from './PageBreak';\nimport RunningHeader from './RunningHeader';\nimport Replace from './Replace';\nimport { Rule } from './Rule';\nimport Split from './Split';\nexport default {\n    Rule,\n    Split(options) {\n        return new Split(options);\n    },\n    Counter(options) {\n        return new Counter(options);\n    },\n    FullBleedPage(options) {\n        return new FullBleedPage(options);\n    },\n    Footnote(options) {\n        return new Footnote(options);\n    },\n    RunningHeader(options) {\n        return new RunningHeader(options);\n    },\n    Replace(options) {\n        return new Replace(options);\n    },\n    FullBleedSpread(options) {\n        return new FullBleedSpread(options);\n    },\n    PageBreak(options) {\n        return new PageBreak(options);\n    },\n    PageReference(options) {\n        return new PageReference(options);\n    },\n    createRule(options) {\n        return new Rule(options);\n    },\n};\n","import rules from '../rules';\nconst { PageBreak, PageReference, Footnote, FullBleedPage, FullBleedSpread, } = rules;\nconst replacer = (element, number) => {\n    element.textContent = `${number}`;\n    return element;\n};\nexport default [\n    PageBreak({ selector: '[book-page-break=\"both\"]', position: 'both' }),\n    PageBreak({ selector: '[book-page-break=\"avoid\"]', position: 'avoid' }),\n    PageBreak({\n        selector: '[book-page-break=\"after\"][book-page-continue=\"right\"]',\n        position: 'after',\n        continue: 'right',\n    }),\n    PageBreak({\n        selector: '[book-page-break=\"after\"][book-page-continue=\"left\"]',\n        position: 'after',\n        continue: 'left',\n    }),\n    PageBreak({\n        selector: '[book-page-break=\"after\"][book-page-continue=\"next\"]',\n        position: 'after',\n        continue: 'next',\n    }),\n    PageBreak({\n        selector: '[book-page-break=\"before\"][book-page-continue=\"right\"]',\n        position: 'before',\n        continue: 'right',\n    }),\n    PageBreak({\n        selector: '[book-page-break=\"before\"][book-page-continue=\"left\"]',\n        position: 'before',\n        continue: 'left',\n    }),\n    PageBreak({\n        selector: '[book-page-break=\"before\"][book-page-continue=\"next\"]',\n        position: 'before',\n        continue: 'next',\n    }),\n    FullBleedPage({ selector: '[book-full-bleed=\"page\"]' }),\n    FullBleedSpread({ selector: '[book-full-bleed=\"spread\"]' }),\n    Footnote({\n        selector: '[book-footnote-text]',\n        render: (element, number) => {\n            const txt = element.getAttribute('book-footnote-text');\n            return `<i>${number}</i>${txt}`;\n        },\n    }),\n    PageReference({\n        selector: '[book-pages-with-text]',\n        replace: replacer,\n        createTest: (element) => {\n            var _a;\n            const text = (_a = element.getAttribute('book-pages-with-text')) !== null && _a !== void 0 ? _a : '';\n            const term = text.toLowerCase().trim();\n            return (pageElement) => {\n                const pageText = pageElement.textContent || '';\n                return pageText.toLowerCase().includes(term);\n            };\n        },\n    }),\n    PageReference({\n        selector: '[book-pages-with-selector]',\n        replace: replacer,\n        createTest: (element) => {\n            var _a;\n            const txt = (_a = element.getAttribute('book-pages-with-selector')) !== null && _a !== void 0 ? _a : '';\n            const selector = txt.trim();\n            return (pageElement) => {\n                return pageElement.querySelector(selector);\n            };\n        },\n    }),\n    PageReference({\n        selector: '[book-pages-with]',\n        replace: replacer,\n        createTest: (element) => {\n            var _a;\n            const text = (_a = element.textContent) !== null && _a !== void 0 ? _a : '';\n            const term = text.toLowerCase().trim();\n            return (pageElement) => {\n                var _a;\n                const pageText = (_a = pageElement.textContent) !== null && _a !== void 0 ? _a : '';\n                return pageText.toLowerCase().includes(term);\n            };\n        },\n    }),\n];\n","import FullBleedPage from '../rules/FullBleedPage';\nimport FullBleedSpread from '../rules/FullBleedSpread';\nimport PageBreak from '../rules/PageBreak';\nconst isSpread = (rule) => rule instanceof FullBleedSpread;\nconst isPage = (rule) => rule instanceof FullBleedPage;\nconst isBreak = (rule) => rule instanceof PageBreak;\nconst isFullPageRule = (rule) => isSpread(rule) || isPage(rule) || isBreak(rule);\nconst dedupe = (inputRules) => {\n    const conflictRules = inputRules.filter(isFullPageRule);\n    const output = inputRules.filter(rule => !conflictRules.includes(rule));\n    const firstSpreadRule = conflictRules.find(isSpread);\n    const firstPageRule = conflictRules.find(isPage);\n    // Only apply one fullpage or fullspread\n    if (firstSpreadRule)\n        output.push(firstSpreadRule);\n    else if (firstPageRule)\n        output.push(firstPageRule);\n    else\n        output.push(...conflictRules); // but multiple pagebreaks are ok\n    return output;\n};\nexport default dedupe;\n","import { classes } from '../dom';\nimport dedupe from './dedupeRules';\nimport recoverFromRule from './recoverFromRule';\nconst giveUp = (rule, el) => {\n    console.warn(`Couldn't apply ${rule.name}, caused overflows twice when adding: `, el);\n};\nfunction isPageRule(rule) {\n    return rule.eachPage;\n}\nfunction isBeforeAddRule(rule) {\n    return !!rule.selector && rule.beforeAdd;\n}\nfunction isAfterAddRule(rule) {\n    return !!rule.selector && rule.afterAdd;\n}\nfunction isOffsetRule(rule) {\n    return rule.pageNumberOffset;\n}\nfunction isDidSplitRule(rule) {\n    return !!rule.selector && rule.didSplit;\n}\nfunction isAvoidSplitRule(rule) {\n    return !!rule.selector && rule.avoidSplit;\n}\nclass RuleSet {\n    constructor(rules) {\n        var _a;\n        const offsetRule = rules.find(isOffsetRule);\n        this.pageNumberOffset = (_a = offsetRule === null || offsetRule === void 0 ? void 0 : offsetRule.pageNumberOffset) !== null && _a !== void 0 ? _a : 0;\n        // Rules for pages\n        this.pageRules = rules.filter(isPageRule);\n        // Rules for elements\n        this.beforeAddRules = rules.filter(isBeforeAddRule);\n        this.afterAddRules = rules.filter(isAfterAddRule);\n        // Rules for layout\n        this.selectorsNotToSplit = rules\n            .filter(isAvoidSplitRule)\n            .map(r => r.selector);\n        this.didSplitRules = rules.filter(isDidSplitRule);\n        // setup\n        rules.filter(r => r.setup).forEach(r => r.setup());\n        this.applySplitRules = this.applySplitRules.bind(this);\n        const allSelectors = rules\n            .map(r => r.selector)\n            .filter(sel => !!sel)\n            .join(', ');\n        if (allSelectors) {\n            const shouldTraverse = (el) => !!el.querySelector(allSelectors);\n            this.shouldTraverse = shouldTraverse.bind(this);\n        }\n        else {\n            this.shouldTraverse = () => false;\n        }\n    }\n    applySplitRules(original, clone) {\n        original.classList.add(classes.toNext);\n        clone.classList.add(classes.fromPrev);\n        this.didSplitRules\n            .filter(r => original.matches(r.selector))\n            .forEach(rule => {\n            rule.didSplit(original, clone);\n        });\n    }\n    // Rules for pages\n    applyPageDoneRules(pg, book) {\n        this.pageRules.forEach(rule => rule.eachPage(pg, book));\n    }\n    finishEveryPage(book) {\n        this.pageRules.forEach(rule => book.pages.forEach(pg => rule.eachPage(pg, book)));\n    }\n    // Rules for elements\n    applyBeforeAddRules(element, book, continueOnNewPage, makeNewPage) {\n        let addedElement = element;\n        const matchingRules = this.beforeAddRules.filter(rule => addedElement.matches(rule.selector));\n        matchingRules.forEach(rule => {\n            addedElement = rule.beforeAdd(addedElement, book, continueOnNewPage, makeNewPage);\n        });\n        return addedElement;\n    }\n    applyAfterAddRules(originalElement, book, continueOnNewPage, makeNewPage) {\n        let addedElement = originalElement;\n        const attemptRecovery = (el) => recoverFromRule(el, book, continueOnNewPage);\n        const matchingRules = this.afterAddRules.filter(rule => addedElement.matches(rule.selector));\n        const uniqueRules = dedupe(matchingRules);\n        uniqueRules.forEach(rule => {\n            const retry = (el) => {\n                attemptRecovery(el);\n                return rule.afterAdd(el, book, continueOnNewPage, makeNewPage, () => giveUp(rule, el));\n            };\n            addedElement = rule.afterAdd(addedElement, book, continueOnNewPage, makeNewPage, retry);\n        });\n        return addedElement;\n    }\n}\nexport default RuleSet;\n","// TODO:\n// While this does catch overflows, it is pretty hacky to move the entire node to the next page.\n// - 1. there is no guarentee it will fit on the new page\n// - 2. if it had childNodes, those side effects will not be undone,\n// which means footnotes will get left on previous page.\n// - 3. if it is a large paragraph, it will leave a large gap. the\n// ideal approach would be to only need to invalidate the last line of text.\nconst recoverFromRule = (el, book, nextRegion) => {\n    let removed = el;\n    const parent = el.parentNode;\n    if (!parent) {\n        throw Error(\"Can't recoverFromRule when element is unparented\");\n    }\n    parent.removeChild(removed);\n    let popped;\n    if (book.currentPage.hasOverflowed()) {\n        parent.appendChild(el);\n        removed = parent;\n        if (!removed.parentNode) {\n            throw Error(\"Can't recoverFromRule when element is unparented\");\n        }\n        removed.parentNode.removeChild(removed);\n        popped = book.currentPage.flow.path.pop();\n        if (book.currentPage.hasOverflowed()) {\n            console.error('Trying again didnt fix it');\n        }\n        else {\n            // Trying again worked\n        }\n    }\n    const newRegion = nextRegion();\n    newRegion.currentElement.appendChild(removed);\n    if (popped)\n        newRegion.path.push(popped);\n};\nexport default recoverFromRule;\n","const sec = (ms) => (ms / 1000).toFixed(2);\nconst estimateFor = (content) => {\n    const start = window.performance.now();\n    const capacity = content.querySelectorAll('*').length;\n    let timeWaiting = 0;\n    let completed = 0;\n    return {\n        increment: () => {\n            completed += 1;\n        },\n        addWaitTime: (t) => {\n            timeWaiting += t;\n        },\n        get progress() {\n            return completed / capacity;\n        },\n        end: () => {\n            const end = window.performance.now();\n            const total = end - start;\n            const layout = total - timeWaiting;\n            console.log(`ðŸ“– Layout ready in ${sec(layout)}s (plus ${sec(timeWaiting)}s waiting for images)`);\n        },\n    };\n};\nexport default estimateFor;\n","import { flowIntoRegions } from 'regionize';\nimport { Book, Page, annotatePages } from '../book';\n// paginate\nimport RuleSet from './RuleSet';\nimport estimateFor from './estimateProgress';\nconst makeBook = async (content, rules, updateProgress) => {\n    if (!Page.isSizeValid())\n        throw Error('Page is too small');\n    const estimator = estimateFor(content);\n    const ruleSet = new RuleSet(rules);\n    const book = new Book();\n    const pageNumberOffset = ruleSet.pageNumberOffset;\n    const makeNewPage = () => new Page();\n    const finishPage = (page, allowOverflow) => {\n        // finished with this page, can display\n        book.updatePageOrder();\n        annotatePages(book.pages, pageNumberOffset);\n        ruleSet.applyPageDoneRules(page, book);\n        page.validateEnd(allowOverflow);\n        book.validate();\n    };\n    const addPageToBook = (allowOverflow = false) => {\n        const oldPage = book.currentPage;\n        if (oldPage)\n            finishPage(oldPage, allowOverflow);\n        const newPage = makeNewPage();\n        book.currentPage = newPage;\n        book.addPage(newPage);\n        updateProgress(book, estimator.progress);\n        newPage.validate();\n        return newPage;\n    };\n    const makeNextRegion = () => {\n        const newPage = addPageToBook();\n        return newPage.flow;\n    };\n    const applySplit = ruleSet.applySplitRules;\n    const dontSplitSel = ruleSet.selectorsNotToSplit;\n    const canSplit = (element) => {\n        if (dontSplitSel.some(sel => element.matches(sel))) {\n            return false;\n        }\n        if (element.parentElement)\n            return canSplit(element.parentElement);\n        return true;\n    };\n    const beforeAdd = async (elementToAdd, continueInNextRegion) => {\n        ruleSet.applyBeforeAddRules(elementToAdd, book, continueInNextRegion, makeNewPage);\n    };\n    const afterAdd = async (addedElement, continueInNextRegion) => {\n        estimator.increment();\n        return ruleSet.applyAfterAddRules(addedElement, book, continueInNextRegion, makeNewPage);\n    };\n    // init\n    content.style.margin = '0';\n    content.style.padding = '0';\n    await flowIntoRegions({\n        content,\n        createRegion: makeNextRegion,\n        applySplit,\n        canSplit,\n        beforeAdd,\n        afterAdd,\n        shouldTraverse: ruleSet.shouldTraverse,\n        didWaitFor: t => estimator.addWaitTime(t),\n    });\n    book.updatePageOrder();\n    annotatePages(book.pages, pageNumberOffset);\n    ruleSet.finishEveryPage(book);\n    estimator.end();\n    return book;\n};\nexport default makeBook;\n","import { parseHTML } from '../dom';\nconst fetchContent = async (url, selector) => {\n    const response = await fetch(url);\n    if (response.status !== 200) {\n        throw Error(`Response ${response.status}: Could not load file at \"${url}\"`);\n    }\n    const fetchedContent = await response.text();\n    const el = parseHTML(fetchedContent, selector);\n    if (!(el instanceof HTMLElement)) {\n        throw Error(`Could not find element that matches selector \"${selector}\" in response from ${url}`);\n    }\n    return el;\n};\nexport const getContentAsElement = async (content) => {\n    if (content instanceof HTMLElement)\n        return content;\n    if (typeof content === 'string') {\n        const el = document.querySelector(content);\n        if (!(el instanceof HTMLElement)) {\n            throw Error(`Could not find element that matches selector \"${content}\"`);\n        }\n        return el;\n    }\n    if (typeof content === 'object' && content.url) {\n        return fetchContent(content.url, content.selector);\n    }\n    throw Error('Content source must be an element or selector');\n};\n","import { ViewerMode, SheetLayout, SheetSize, SheetMarks } from '../constants';\n// TODO: This is not a particularly robust check.\nconst supportsCustomSheetSize = !!window.hasOwnProperty('chrome');\nconst getSheetSizeLabels = (pageSize) => {\n    const sizeName = `${pageSize.width} Ã— ${pageSize.height}`;\n    if (!supportsCustomSheetSize) {\n        return [\n            [SheetSize.LETTER_PORTRAIT, 'Default Page Size *'],\n            [\n                SheetSize.LETTER_PORTRAIT,\n                \"Only Chrome supports custom page sizes. Set in your browser's print dialog instead.\",\n            ],\n        ];\n    }\n    return [\n        [SheetSize.AUTO, `${sizeName}`],\n        [SheetSize.AUTO_BLEED, `${sizeName} + Bleed`],\n        [SheetSize.AUTO_MARKS, `${sizeName} + Marks`],\n        [SheetSize.LETTER_PORTRAIT, 'Letter Portrait'],\n        [SheetSize.LETTER_LANDSCAPE, 'Letter Landscape'],\n        [SheetSize.A4_PORTRAIT, 'A4 Portrait'],\n        [SheetSize.A4_LANDSCAPE, 'A4 Landscape'],\n    ];\n};\nconst marksLabels = [\n    [SheetMarks.NONE, 'No Marks'],\n    [SheetMarks.CROP, 'Crop Marks'],\n    [SheetMarks.BLEED, 'Bleed Marks'],\n    [SheetMarks.BOTH, 'Crop and Bleed'],\n];\nconst modeLabels = [\n    [ViewerMode.PREVIEW, 'Grid'],\n    [ViewerMode.FLIPBOOK, 'Flipbook'],\n    [ViewerMode.PRINT, 'Print Preview'],\n];\nconst layoutLabels = [\n    [SheetLayout.PAGES, '1 Page / Sheet'],\n    [SheetLayout.SPREADS, '1 Spread / Sheet'],\n    [SheetLayout.BOOKLET, 'Booklet Sheets'],\n];\nexport { getSheetSizeLabels, marksLabels, modeLabels, layoutLabels };\n","import { div, button, select, option } from '../dom';\nconst row = (cls, ...children) => {\n    return div(`${cls}.row`, ...children);\n};\n// Button\nconst btn = (cls, attrs, label) => {\n    return button(`.control.btn${cls}`, attrs, label);\n};\nconst dropdown = (attrs, options) => {\n    const selectVal = div('.select-val', 'Value');\n    const selectEl = select('.select', attrs, ...options);\n    selectVal.textContent = selectEl.options[selectEl.selectedIndex].text;\n    return div('.select-wrap.control', selectVal, selectEl);\n};\nconst enumDropdown = (entries, initialValue, changeHandler) => {\n    const eventHandler = (e) => {\n        const rawVal = e.target.value;\n        const chosenEntry = entries.filter(entry => entry[0].toString() === rawVal)[0];\n        if (chosenEntry) {\n            changeHandler(chosenEntry[0]);\n        }\n        else {\n            throw Error('Selected unknown value');\n        }\n    };\n    return dropdown({ onchange: eventHandler }, entries.map(entry => {\n        const el = option({ value: entry[0] }, entry[1]);\n        if (entry[0] === initialValue) {\n            el.selected = true;\n        }\n        return el;\n    }));\n};\nexport { row, btn, dropdown, option, div, enumDropdown };\n","import { ViewerMode, SheetSize } from '../constants';\nimport { getSheetSizeLabels, marksLabels, modeLabels, layoutLabels, } from './labels';\nimport { btn, row, div, enumDropdown } from './components';\nconst renderPrintOptions = (state, actions) => {\n    const shouldShowMarks = state.paper !== SheetSize.AUTO && state.paper !== SheetSize.AUTO_BLEED;\n    const sizeLabels = getSheetSizeLabels(state.pageSize);\n    return row('.print-options', row(null, enumDropdown(layoutLabels, state.layout, actions.setLayout)), row(null, enumDropdown(sizeLabels, state.paper, actions.setPaper)), shouldShowMarks\n        ? row(null, enumDropdown(marksLabels, state.marks, actions.setMarks))\n        : '');\n};\nclass Controls {\n    constructor() {\n        this.element = div('.controls');\n    }\n    update(state, actions) {\n        const oldElement = this.element;\n        const newElement = this.render(state, actions);\n        oldElement.replaceWith(newElement);\n        this.element = newElement;\n    }\n    render(state, actions) {\n        const print = () => {\n            actions.setMode(ViewerMode.PRINT);\n            setTimeout(window.print, 10);\n        };\n        const shouldShowPrint = state.mode === ViewerMode.PRINT;\n        return div('.controls', row('.view-row', enumDropdown(modeLabels, state.mode, actions.setMode)), shouldShowPrint ? renderPrintOptions(state, actions) : '', btn('.btn-print.btn-main', { onclick: print }, 'Print'));\n    }\n}\nexport default Controls;\n","const padPages = (pages, makePage) => {\n    if (pages.length % 2 !== 0) {\n        const pg = makePage();\n        pages.push(pg);\n    }\n    const spacerPage = makePage();\n    const spacerPage2 = makePage();\n    spacerPage.element.style.visibility = 'hidden';\n    spacerPage2.element.style.visibility = 'hidden';\n    pages.unshift(spacerPage);\n    pages.push(spacerPage2);\n    return pages;\n};\nexport default padPages;\n","import { Page } from '../book';\nimport { div } from '../dom';\nimport padPages from './padPages';\nconst twoPageSpread = (...children) => {\n    return div('.spread-wrapper.spread-centered.spread-size', ...children);\n};\nconst onePageSpread = (...children) => {\n    return div('.spread-wrapper.spread-centered.page-size', ...children);\n};\nconst renderGridViewer = (bookPages, isTwoUp) => {\n    const pages = isTwoUp ? padPages(bookPages, () => new Page()) : bookPages;\n    const gridLayout = document.createDocumentFragment();\n    if (isTwoUp) {\n        for (let i = 0; i < pages.length; i += 2) {\n            const wrap = twoPageSpread(pages[i].element, pages[i + 1].element);\n            gridLayout.appendChild(wrap);\n        }\n    }\n    else {\n        pages.forEach(pg => {\n            const wrap = onePageSpread(pg.element);\n            gridLayout.appendChild(wrap);\n        });\n    }\n    return gridLayout;\n};\nexport { renderGridViewer };\n","import { div } from '../dom';\nconst directions = ['top', 'bottom', 'left', 'right'];\nconst bleedMarks = () => directions.map(dir => div(`.mark-bleed-${dir}`));\nconst cropMarks = () => directions.map(dir => div(`.mark-crop-${dir}`));\nconst pageSheetMarks = () => div('.page-size.print-mark-wrap', ...cropMarks(), ...bleedMarks());\nconst spreadSheetMarks = () => div('.spread-size.print-mark-wrap', div('.mark-crop-fold'), ...cropMarks(), ...bleedMarks());\nconst bookletMeta = (i, len) => {\n    const isFront = i % 4 === 0;\n    const sheetIndex = Math.round((i + 1) / 4) + 1;\n    return div('.print-meta', `Sheet ${sheetIndex} of ${len / 4}: ${isFront ? 'Outside' : 'Inside'}`);\n};\nexport { pageSheetMarks, spreadSheetMarks, bookletMeta };\n","import { div, classes } from '../dom';\nimport { Page } from '../book';\nimport { SheetLayout } from '../constants';\nimport { pageSheetMarks, spreadSheetMarks, bookletMeta } from './sheetMarks';\nimport padPages from './padPages';\nimport orderPagesBooklet from './orderPagesBooklet';\nconst twoPageSpread = (...children) => {\n    return div('.spread-wrapper', ...children);\n};\nconst onePageSpread = (...children) => {\n    return div('.spread-wrapper', ...children);\n};\nconst renderSheetViewer = (bookPages, _doubleSided, layout) => {\n    const isTwoUp = layout !== SheetLayout.PAGES;\n    const isSpreads = layout === SheetLayout.SPREADS;\n    const isBooklet = layout === SheetLayout.BOOKLET;\n    let pages = bookPages;\n    if (isSpreads)\n        pages = padPages(pages, () => new Page());\n    else if (isBooklet)\n        pages = orderPagesBooklet(pages, () => new Page());\n    const printLayout = document.createDocumentFragment();\n    const marks = isTwoUp ? spreadSheetMarks : pageSheetMarks;\n    const spread = isTwoUp ? twoPageSpread : onePageSpread;\n    const printSheet = (...children) => {\n        return div('.print-sheet', spread(...children));\n    };\n    if (isTwoUp) {\n        for (let i = 0; i < pages.length; i += 2) {\n            const spreadMarks = marks();\n            if (isBooklet) {\n                const meta = bookletMeta(i, pages.length);\n                spreadMarks.appendChild(meta);\n            }\n            const sheet = printSheet(div('.page-bleed-clip.page-bleed-clip-left', pages[i].element), div('.page-bleed-clip.page-bleed-clip-right', pages[i + 1].element), spreadMarks);\n            sheet.classList.add(classes.sheetSpread);\n            printLayout.appendChild(sheet);\n        }\n    }\n    else {\n        pages.forEach(pg => {\n            const sheet = printSheet(pg.element, marks());\n            sheet.classList.add(pg.isLeft ? classes.sheetLeft : classes.sheetRight);\n            printLayout.appendChild(sheet);\n        });\n    }\n    return printLayout;\n};\nexport { renderSheetViewer };\n","const orderPagesBooklet = (pages, makePage) => {\n    while (pages.length % 4 !== 0) {\n        const spacerPage = makePage();\n        spacerPage.element.style.visibility = 'hidden';\n        pages.push(spacerPage);\n    }\n    const bookletOrder = [];\n    const len = pages.length;\n    for (let i = 0; i < len / 2; i += 2) {\n        bookletOrder.push(pages[len - 1 - i]);\n        bookletOrder.push(pages[i]);\n        bookletOrder.push(pages[i + 1]);\n        bookletOrder.push(pages[len - 2 - i]);\n    }\n    return bookletOrder;\n};\nexport default orderPagesBooklet;\n","import { Page } from '../book';\nimport { prefixer, div } from '../dom';\nimport padPages from './padPages';\nconst renderFlipbookViewer = (bookPages, doubleSided) => {\n    const pages = padPages(bookPages, () => new Page());\n    const flipLayout = document.createDocumentFragment();\n    const sizer = div('.spread-size.flip-sizer');\n    const flapHolder = div('.spread-size.flap-holder');\n    sizer.appendChild(flapHolder);\n    flipLayout.appendChild(sizer);\n    const flaps = [];\n    let currentLeaf = -1;\n    let leftOffset = 4;\n    if (pages.length * leftOffset > 60) {\n        leftOffset = 60 / pages.length;\n    }\n    flapHolder.style.width = `${pages.length * leftOffset}px`;\n    const setLeaf = (n) => {\n        let newLeaf = n;\n        if (newLeaf === currentLeaf)\n            newLeaf += 1;\n        currentLeaf = newLeaf;\n        let zScale = 4;\n        if (flaps.length * zScale > 200)\n            zScale = 200 / flaps.length;\n        flaps.forEach((flap, i, arr) => {\n            // + 0.5 so left and right are even\n            const z = (arr.length - Math.abs(i - newLeaf + 0.5)) * zScale;\n            flap.style.transform = `translate3d(${i < newLeaf ? 4 : 0}px,0,${z}px) rotateY(${i < newLeaf ? -180 : 0}deg)`;\n        });\n    };\n    let leafIndex = 0;\n    for (let i = 1; i < pages.length - 1; i += doubleSided ? 2 : 1) {\n        leafIndex += 1;\n        const li = leafIndex;\n        const flap = div('.page3d');\n        flap.addEventListener('click', () => {\n            const newLeaf = li - 1;\n            setLeaf(newLeaf);\n        });\n        const rightPage = pages[i].element;\n        let leftPage;\n        rightPage.classList.add(prefixer('page3d-front'));\n        flap.appendChild(rightPage);\n        if (doubleSided) {\n            flap.classList.add(prefixer('doubleSided'));\n            leftPage = pages[i + 1].element;\n        }\n        else {\n            leftPage = div('.page');\n        }\n        leftPage.classList.add(prefixer('page3d-back'));\n        flap.appendChild(leftPage);\n        // TODO: Dynamically add/remove pages.\n        // Putting 1000s of elements onscreen\n        // locks up the browser.\n        flap.style.left = `${i * leftOffset}px`;\n        flaps.push(flap);\n        flapHolder.appendChild(flap);\n    }\n    setLeaf(0);\n    return flipLayout;\n};\nexport { renderFlipbookViewer };\n","export const getScrollAsPercent = () => {\n    if (!document || !document.scrollingElement)\n        return 0;\n    const el = document.scrollingElement;\n    return el.scrollTop / el.scrollHeight;\n};\nexport const scrollToPercent = (newVal) => {\n    if (!document.scrollingElement)\n        return;\n    const el = document.scrollingElement;\n    el.scrollTop = el.scrollHeight * newVal;\n};\nexport const scrollToBottom = () => {\n    const scroll = document.scrollingElement;\n    if (!scroll)\n        return;\n    const scrollMax = scroll.scrollHeight - scroll.offsetHeight;\n    scroll.scrollTop = scrollMax;\n};\n","const isCommandP = (e) => {\n    return (e.ctrlKey || e.metaKey) && e.keyCode === 80;\n};\n// Automatically switch into print mode\nconst listenForPrint = (beforePrint) => {\n    if (window.matchMedia) {\n        const mediaQueryList = window.matchMedia('print');\n        mediaQueryList.addListener(mql => {\n            if (mql.matches) {\n                // before print\n                beforePrint();\n            }\n            else {\n                // after print\n            }\n        });\n    }\n    document.body.addEventListener('keydown', e => {\n        if (isCommandP(e)) {\n            e.preventDefault();\n            beforePrint();\n            setTimeout(() => window.print(), 200);\n        }\n    });\n};\nexport default listenForPrint;\n","import { Page } from '../book';\nimport Controls from '../controls';\nimport { ViewerMode, SheetMarks, SheetLayout } from '../constants';\nimport { classes, allModeClasses, classForMode, div } from '../dom';\nimport { throttleFrame, throttleTime } from '../utils';\nimport { renderGridViewer } from './gridViewer';\nimport { renderSheetViewer } from './sheetViewer';\nimport { renderFlipbookViewer } from './flipbookViewer';\nimport { scrollToBottom, scrollToPercent, getScrollAsPercent, } from './scrollUtils';\nimport errorView from './error';\nimport listenForPrint from './listenForPrint';\nconst throttleProgressBar = throttleFrame();\nconst throttleRender = throttleTime(100);\nconst throttleResize = throttleTime(50);\nconst document = window.document;\nconst pageSpread = (...pgs) => {\n    return div('.spread-wrapper.spread-centered.spread-size', ...pgs);\n};\nclass Viewer {\n    constructor({ pageSetup, mode, layout, marks }) {\n        this.hasRendered = false;\n        this.pageSetup = pageSetup;\n        this.controls = new Controls();\n        this.updateControls();\n        this.progressBar = div('.progress-bar');\n        this.content = div('.zoom-content');\n        this.scaler = div('.zoom-scaler', this.content);\n        this.element = div('.root', this.progressBar, this.controls.element, this.scaler);\n        this.isDoubleSided = true;\n        this.sheetLayout = layout;\n        this.marks = marks;\n        this.mode = mode;\n        this.element.classList.add(classes.viewPreview);\n        this.currentLeaf = 0;\n        listenForPrint(() => {\n            this.mode = ViewerMode.PRINT;\n            this.render();\n        });\n        window.addEventListener('resize', () => {\n            throttleResize(() => this.scaleToFit());\n        });\n        this.setInProgress(true);\n        this.setMarks(marks);\n        this.show();\n    }\n    updateControls() {\n        this.controls.update({\n            // Initial props\n            paper: this.pageSetup.paper,\n            layout: this.sheetLayout,\n            mode: this.mode,\n            marks: this.marks,\n            pageSize: this.pageSetup.displaySize,\n        }, {\n            // Actions\n            setMode: this.setMode.bind(this),\n            setPaper: this.setSheetSize.bind(this),\n            setLayout: this.setLayout.bind(this),\n            setMarks: this.setMarks.bind(this),\n        });\n    }\n    setMode(newMode) {\n        if (newMode === this.mode)\n            return;\n        this.mode = newMode;\n        this.updateControls();\n        this.render();\n    }\n    get isInProgress() {\n        return this.element.classList.contains(classes.inProgress);\n    }\n    setInProgress(newVal) {\n        this.element.classList.toggle(classes.inProgress, newVal);\n    }\n    get isTwoUp() {\n        return this.sheetLayout !== SheetLayout.PAGES;\n    }\n    setShowingCropMarks(newVal) {\n        this.element.classList.toggle(classes.showCrop, newVal);\n    }\n    setShowingBleedMarks(newVal) {\n        this.element.classList.toggle(classes.showBleedMarks, newVal);\n    }\n    setShowingBleed(newVal) {\n        this.element.classList.toggle(classes.showBleed, newVal);\n    }\n    get isViewing() {\n        return document.body.classList.contains(classes.isViewing);\n    }\n    set isViewing(newVal) {\n        document.body.classList.toggle(classes.isViewing, newVal);\n    }\n    setSheetSize(newVal) {\n        this.pageSetup.paper = newVal;\n        this.pageSetup.updateStyleVars();\n        this.mode = ViewerMode.PRINT;\n        this.render();\n        this.scaleToFit();\n        setTimeout(() => {\n            this.scaleToFit();\n        }, 300);\n    }\n    setLayout(newVal) {\n        if (newVal === this.sheetLayout)\n            return;\n        this.sheetLayout = newVal;\n        this.pageSetup.printTwoUp = this.isTwoUp;\n        this.pageSetup.updateStyleVars();\n        this.mode = ViewerMode.PRINT;\n        this.render();\n    }\n    setMarks(newVal) {\n        this.marks = newVal;\n        this.updateControls();\n        this.setShowingCropMarks(newVal === SheetMarks.CROP || newVal === SheetMarks.BOTH);\n        this.setShowingBleedMarks(newVal === SheetMarks.BLEED || newVal === SheetMarks.BOTH);\n    }\n    displayError(title, text) {\n        this.show();\n        if (!this.error) {\n            this.error = errorView(title, text);\n            this.element.appendChild(this.error);\n            scrollToBottom();\n            if (this.book) {\n                const flow = this.book.currentPage.flow;\n                if (flow)\n                    flow.currentElement.style.outline = '3px solid red';\n            }\n        }\n    }\n    clear() {\n        this.book = undefined;\n        this.lastSpreadInProgress = undefined; // TODO: Make this clearer, after first render\n        this.content.innerHTML = '';\n    }\n    show() {\n        if (this.element.parentNode)\n            return;\n        document.body.appendChild(this.element);\n        this.isViewing = true;\n    }\n    hide() {\n        var _a;\n        // TODO this doesn't work if the target is an existing node\n        (_a = this.element.parentNode) === null || _a === void 0 ? void 0 : _a.removeChild(this.element);\n        this.isViewing = false;\n    }\n    render(newBook) {\n        if (newBook)\n            this.book = newBook;\n        if (!this.book)\n            return;\n        this.show();\n        this.updateControls();\n        this.element.classList.remove(...allModeClasses);\n        this.element.classList.add(classForMode(this.mode));\n        this.setShowingBleed(this.mode === ViewerMode.PRINT);\n        const prevScroll = getScrollAsPercent();\n        this.setProgressAmount(1);\n        window.requestAnimationFrame(() => {\n            if (!this.book)\n                throw Error('Book missing');\n            const pages = this.book.pages.slice();\n            const render = this.renderFunctionFor(this.mode);\n            const fragment = render(pages, this.isDoubleSided, this.sheetLayout);\n            this.content.innerHTML = '';\n            this.content.append(fragment);\n            if (!this.hasRendered)\n                this.hasRendered = true;\n            else\n                scrollToPercent(prevScroll);\n            this.scaleToFit();\n        });\n    }\n    renderFunctionFor(mode) {\n        if (mode === ViewerMode.PREVIEW)\n            return renderGridViewer;\n        else if (mode === ViewerMode.FLIPBOOK)\n            return renderFlipbookViewer;\n        else if (mode === ViewerMode.PRINT)\n            return renderSheetViewer;\n        throw Error(`Invalid layout mode: ${this.mode} (type ${typeof this.mode})`);\n    }\n    setProgressAmount(newVal) {\n        if (newVal < 1) {\n            throttleProgressBar(() => {\n                this.progressBar.style.transform = `scaleX(${newVal})`;\n            });\n        }\n        else {\n            this.progressBar.style.transform = '';\n        }\n    }\n    updateProgress(book, estimatedProgress) {\n        this.book = book;\n        this.setProgressAmount(estimatedProgress);\n        if (!document.scrollingElement)\n            return;\n        const scroller = document.scrollingElement;\n        // don't bother rerendering if preview is out of view\n        const scrollTop = scroller.scrollTop;\n        const scrollH = scroller.scrollHeight;\n        const h = scroller.offsetHeight;\n        if (scrollH > h * 3 && scrollTop < h)\n            return;\n        // don't rerender too often\n        throttleRender(() => this.renderProgress(book, estimatedProgress));\n    }\n    renderProgress(book, estimatedProgress) {\n        const needsZoomUpdate = !this.content.firstElementChild;\n        const sideBySide = this.mode === ViewerMode.PREVIEW ||\n            (this.mode === ViewerMode.PRINT &&\n                this.sheetLayout !== SheetLayout.PAGES);\n        const limit = sideBySide ? 2 : 1;\n        book.pages.forEach((page, i) => {\n            if (this.content.contains(page.element) &&\n                page.element.parentNode !== this.content)\n                return;\n            if (this.lastSpreadInProgress &&\n                this.lastSpreadInProgress.children.length < limit) {\n                this.lastSpreadInProgress.append(page.element);\n                return;\n            }\n            this.lastSpreadInProgress = pageSpread(page.element);\n            if (i === 0 && sideBySide) {\n                const spacer = new Page();\n                spacer.element.style.visibility = 'hidden';\n                this.lastSpreadInProgress.insertBefore(spacer.element, this.lastSpreadInProgress.firstElementChild);\n            }\n            this.content.append(this.lastSpreadInProgress);\n        });\n        if (needsZoomUpdate)\n            this.scaleToFit();\n    }\n    scaleToFit() {\n        if (!this.content.firstElementChild)\n            return;\n        const prevScroll = getScrollAsPercent();\n        this.scaler.style.transform = `scale(${this.scaleThatFits})`;\n        scrollToPercent(prevScroll);\n    }\n    get scaleThatFits() {\n        const viewerW = this.scaler.getBoundingClientRect().width;\n        const contentW = this.content.getBoundingClientRect().width;\n        return Math.min(1, viewerW / contentW);\n    }\n}\nexport default Viewer;\n","/* global BINDERY_VERSION */\nimport { div } from '../dom';\nexport default function (title, text) {\n    return div('.error', div('.error-title', title), div('.error-text', text), div('.error-footer', `Bindery ${BINDERY_VERSION}`));\n}\n","/* global BINDERY_VERSION */\n// main\nimport PageSetup from './page-setup';\nimport { ViewerMode, SheetSize, SheetLayout, SheetMarks } from './constants';\nimport defaultRules from './defaults';\n// components\nimport makeBook from './makeBook';\nimport { getContentAsElement } from './makeBook/getContent';\nimport Viewer from './viewer';\nimport rules from './rules';\nimport { validateRuntimeOptions, RuntimeTypes } from './runtimeOptionChecker';\nimport { Rule } from './rules/Rule';\nconst vals = (obj) => {\n    return Object.keys(obj).map(k => obj[k]);\n};\nconst nextFrame = () => new Promise(resolve => {\n    requestAnimationFrame(t => resolve(t));\n});\nclass Bindery {\n    constructor(opts = {}) {\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j;\n        console.log(`ðŸ“– Bindery ${BINDERY_VERSION}`);\n        validateRuntimeOptions(opts, {\n            name: 'makeBook',\n            autorun: RuntimeTypes.bool,\n            content: RuntimeTypes.any,\n            view: RuntimeTypes.enum(...vals(ViewerMode)),\n            pageNumberOffset: RuntimeTypes.number,\n            pageSetup: RuntimeTypes.shape({\n                name: 'pageSetup',\n                margin: RuntimeTypes.margin,\n                size: RuntimeTypes.size,\n            }),\n            printSetup: RuntimeTypes.shape({\n                name: 'printSetup',\n                bleed: RuntimeTypes.length,\n                layout: RuntimeTypes.enum(...vals(SheetLayout)),\n                marks: RuntimeTypes.enum(...vals(SheetMarks)),\n                paper: RuntimeTypes.enum(...vals(SheetSize)),\n            }),\n            rules: RuntimeTypes.array,\n        });\n        this.autorun = (_a = opts.autorun) !== null && _a !== void 0 ? _a : true;\n        this.autoupdate = (_b = opts.autoupdate) !== null && _b !== void 0 ? _b : false;\n        this.pageSetup = new PageSetup(opts.pageSetup, opts.printSetup);\n        const startLayout = (_d = (_c = opts.printSetup) === null || _c === void 0 ? void 0 : _c.layout) !== null && _d !== void 0 ? _d : SheetLayout.PAGES;\n        const startMarks = (_f = (_e = opts.printSetup) === null || _e === void 0 ? void 0 : _e.marks) !== null && _f !== void 0 ? _f : SheetMarks.CROP;\n        this.viewer = new Viewer({\n            pageSetup: this.pageSetup,\n            mode: (_g = opts.view) !== null && _g !== void 0 ? _g : ViewerMode.PREVIEW,\n            marks: startMarks,\n            layout: startLayout,\n        });\n        if (!opts.content) {\n            this.viewer.displayError('Content not specified', 'You must include a source element, selector, or url');\n            throw Error('Bindery: You must include a source element or selector');\n        }\n        if (opts.ControlsComponent) {\n            this.viewer.displayError('Controls are now included', 'Please remove the controls component');\n            throw Error('Bindery: controls are now included');\n        }\n        this.rules = defaultRules;\n        this.rules.push(new Rule({ pageNumberOffset: (_h = opts.pageNumberOffset) !== null && _h !== void 0 ? _h : 0 }));\n        (_j = opts.rules) === null || _j === void 0 ? void 0 : _j.forEach(rule => {\n            if (rule instanceof rules.Rule) {\n                this.rules.push(rule);\n            }\n            else {\n                throw Error(`Bindery: The following is not an instance of Bindery.Rule and will be ignored: ${rule}`);\n            }\n        });\n        if (this.autorun)\n            this.makeBook(opts.content);\n    }\n    // Convenience constructor\n    static makeBook(opts = {}) {\n        var _a;\n        opts.autorun = (_a = opts.autorun) !== null && _a !== void 0 ? _a : true;\n        return new Bindery(opts);\n    }\n    cancel() {\n        this.viewer.hide();\n        if (this.content)\n            this.content.style.display = '';\n    }\n    async makeBook(contentDescription) {\n        try {\n            this.content = await getContentAsElement(contentDescription);\n        }\n        catch (e) {\n            this.viewer.show();\n            this.viewer.displayError('', e.message);\n            // throw e;\n            return undefined;\n        }\n        this.content.style.display = '';\n        const content = this.content.cloneNode(true);\n        this.content.style.display = 'none';\n        this.viewer.clear(); // In case we're updating an existing layout\n        this.viewer.show();\n        this.pageSetup.updateStyleVars();\n        this.viewer.setInProgress(true);\n        const onProgress = (currentBook, progress) => {\n            this.viewer.updateProgress(currentBook, progress);\n        };\n        try {\n            const book = await makeBook(content, this.rules, onProgress);\n            this.viewer.setProgressAmount(1);\n            await nextFrame();\n            this.viewer.render(book);\n            this.viewer.setInProgress(false);\n            return book;\n        }\n        catch (e) {\n            this.viewer.setInProgress(false);\n            this.viewer.displayError(\"Layout couldn't complete\", e.message);\n            // throw e;\n            return undefined;\n        }\n    }\n}\nexport default Bindery;\n","/* global BINDERY_VERSION */\nimport Bindery from './bindery';\nimport rules from './rules';\nimport { ViewerMode, SheetSize, SheetLayout, SheetMarks } from './constants';\nimport '../src/main.scss';\nconst constants = {\n    View: ViewerMode,\n    Paper: SheetSize,\n    Layout: SheetLayout,\n    Marks: SheetMarks,\n    version: BINDERY_VERSION\n};\nconst BinderyWithRules = Object.assign(Bindery, rules, constants);\nexport default BinderyWithRules;\n"],"names":["SheetLayout","SheetMarks","SheetSize","ViewerMode","prefixer","str","substr","classes","showBleed","showCrop","showBleedMarks","isViewing","viewPreview","viewPrint","viewFlip","inProgress","leftPage","rightPage","isOverflowing","printSheet","sheetSpread","sheetLeft","sheetRight","toNext","fromPrev","Object","keys","forEach","k","key","val","prefix","allModeClasses","h","tagName","classNames","attrs","children","el","document","createElement","className","split","filter","txt","map","join","v","setAttribute","append","div","cls","safeMeasure","measureCallback","parentNode","measureArea","querySelector","c","body","appendChild","firstElementChild","innerHTML","doc","window","stylesheet","id","_a","style","head","addStylesheet","throttleTime","ms","queued","wasCalled","inner","func","setTimeout","queuedFunc","undefined","formatAsRanges","pageNumbers","prevNum","isInARange","endRange","endNum","addComma","num","endAndAdd","i","isLast","length","isAdjacent","addFirst","addLast","cssNumberRegEx","isLength","test","bleed","size","width","height","margin","outer","bottom","top","letter","freeze","a4","supportsCustomPageSize","hasOwnProperty","PageSetup","[object Object]","opts","printOpts","_b","_c","this","defaultPageSetup","markLength","paper","AUTO","AUTO_MARKS","printTwoUp","layout","PAGES","displaySize","spreadSize","sheetSize","doubleBleed","doubleMarks","singleMarks","AUTO_BLEED","LETTER_LANDSCAPE","LETTER_PORTRAIT","A4_PORTRAIT","A4_LANDSCAPE","Error","w","matches","match","Number","unit","parseLength","page","sheet","cssVariables","spread-width","page-width","page-height","sheet-width","sheet-height","margin-inner","margin-outer","margin-top","margin-bottom","mark-length","rootRule","entries","pageRule","Rule","options","name","selector","validateRuntimeOptions","validOpts","setName","type","check","optName","valName","JSON","stringify","isObj","hasSameKeys","required","some","obj","prototype","call","hasProp","isShape","template","input","isShapeExact","isEnum","cases","includes","lengthChecker","RuntimeTypes","any","enum","shapeExact","shape","string","number","bool","array","Array","isArray","Counter","super","counterValue","incrementEl","resetEl","replaceEl","replace","createReplacement","element","textContent","OutOfFlow","elmt","book","makeNewPage","continueOnNewPage","createOutOfFlowPages","continue","currentPage","hasOutOfFlowContent","setPreference","FullBleedSpread","rotate","removeChild","isEmpty","addPage","rotateContainer","background","classList","add","isOutOfFlow","avoidReorder","cloneNode","FullBleedPage","newPage","Replace","overflowCallback","parent","console","error","defensiveClone","replacement","replaceChild","hasOverflowed","info","insertAdjacentHTML","Footnote","render","footer","footnote","contents","HTMLElement","afterAdd","overflowEl","Region","suppressErrors","content","position","path","newPath","currentElement","len","trim","offsetHeight","box","getBoundingClientRect","contentH","boxH","overflowAmount","isContentElement","node","nodeType","Node","ELEMENT_NODE","isElement","isScript","lastYieldTime","yieldIfNecessary","async","performance","now","Promise","resolve","requestAnimationFrame","t","ignoreOverflow","hasAttribute","parentElement","nextWordEnd","text","startIndex","newIndex","charAt","createTextNode","bind","addInOneGo","textNode","container","success","completed","fillWords","getNextContainer","textLayout","originalText","nodeValue","proposedEnd","wordEnd","previousWordEnd","fittingText","overflowingText","remainder","fillWordsUntilOverflow","nextContainer","tryInNextRegion","region","makeNextRegion","canSplit","startLength","elementToMove","pop","nearestMoveableElement","pathToRestore","unshift","nextRegion","r","push","clone","withChildren","shallowClone","deepClone","noop","always","never","flowIntoRegions","_d","_e","_f","createRegion","applySplit","beforeAdd","didWaitFor","shouldTraverse","currentRegion","canSplitCurrent","ignoreCurrentOverflow","splitRules","original","nextChild","prevStart","parseInt","getAttribute","newStart","preserveNumbering","columns","currentIndex","indexOf","origCol","clonedCol","preserveTableColumns","continueInNextRegion","prevRegion","oldPath","applyRules","deepCloneWithRules","clonePath","setPath","continuedParent","addText","isSplittable","addElement","isImage","naturalWidth","waitTime","image","imgStart","failed","addEventListener","src","ensureImageLoaded","shouldTraverseChildren","clearAndAddChildren","addedElement","childNodes","shouldSplit","child","TEXT_NODE","HierarchyToHeadingAdapter","getter","getHierarchy","sel","find","entry","h1","textFor","h2","h3","h4","h5","h6","Page","hierarchy","suppress","alwaysLeft","alwaysRight","flow","heading","testPage","isReasonableSize","dir","side","toggle","isLeft","isRight","preferLeft","newVal","suspect","warn","allowOverflow","indexOfNextReorderablePage","pages","pg","Book","rawPages","orderedPages","updatePageOrder","pageCount","slice","indexToSwap","pageToMoveUp","splice","orderPages","annotatePages","offset","setLeftRight","annotatePagesNumbers","headerSelectorHierarchy","currentHierarchy","pageHierarchy","annotatePagesHierarchy","pageNumbersForTest","PageReference","createTest","references","throttle","throttledUpdate","updatePageReferences","createReference","ref","value","currentResults","newValue","a","b","shallowEqual","isResolved","pageRanges","newRender","href","startsWithNumber","data","PageBreak","avoidSplit","RunningHeader","runningHeader","Split","fromPrevious","didSplit","createRule","rules","replacer","term","toLowerCase","pageElement","isSpread","rule","isPage","isFullPageRule","isBreak","isPageRule","eachPage","isBeforeAddRule","isAfterAddRule","isOffsetRule","pageNumberOffset","isDidSplitRule","isAvoidSplitRule","RuleSet","offsetRule","pageRules","beforeAddRules","afterAddRules","selectorsNotToSplit","didSplitRules","setup","applySplitRules","allSelectors","originalElement","attemptRecovery","removed","popped","newRegion","recoverFromRule","inputRules","conflictRules","output","firstSpreadRule","firstPageRule","dedupe","giveUp","sec","toFixed","makeBook","updateProgress","isSizeValid","estimator","start","capacity","querySelectorAll","timeWaiting","increment","addWaitTime","progress","end","log","estimateFor","ruleSet","addPageToBook","oldPage","applyPageDoneRules","validateEnd","validate","finishPage","dontSplitSel","padding","elementToAdd","applyBeforeAddRules","applyAfterAddRules","finishEveryPage","fetchContent","url","response","fetch","status","wrapper","parseHTML","supportsCustomSheetSize","marksLabels","NONE","CROP","BLEED","BOTH","modeLabels","PREVIEW","FLIPBOOK","PRINT","layoutLabels","SPREADS","BOOKLET","row","btn","label","button","dropdown","selectVal","selectEl","optionElements","select","selectedIndex","enumDropdown","initialValue","changeHandler","onchange","e","rawVal","target","chosenEntry","toString","selected","renderPrintOptions","state","actions","shouldShowMarks","sizeLabels","pageSize","sizeName","getSheetSizeLabels","setLayout","setPaper","marks","setMarks","Controls","oldElement","newElement","replaceWith","shouldShowPrint","mode","setMode","onclick","print","padPages","makePage","spacerPage","spacerPage2","visibility","twoPageSpread","renderGridViewer","bookPages","isTwoUp","gridLayout","createDocumentFragment","wrap","onePageSpread","directions","bleedMarks","cropMarks","pageSheetMarks","spreadSheetMarks","bookletMeta","isFront","sheetIndex","Math","round","renderSheetViewer","_doubleSided","isSpreads","isBooklet","bookletOrder","orderPagesBooklet","printLayout","spread","spreadMarks","meta","renderFlipbookViewer","doubleSided","flipLayout","sizer","flapHolder","flaps","currentLeaf","leftOffset","setLeaf","n","newLeaf","zScale","flap","arr","z","abs","transform","leafIndex","li","left","getScrollAsPercent","scrollingElement","scrollTop","scrollHeight","scrollToPercent","throttleProgressBar","throttleFrame","throttleRender","throttleResize","Viewer","pageSetup","hasRendered","controls","updateControls","progressBar","scaler","isDoubleSided","sheetLayout","beforePrint","matchMedia","addListener","mql","ctrlKey","metaKey","keyCode","isCommandP","preventDefault","listenForPrint","scaleToFit","setInProgress","show","update","setSheetSize","newMode","isInProgress","contains","updateStyleVars","setShowingCropMarks","setShowingBleedMarks","title","errorView","scroll","scrollMax","scrollToBottom","outline","lastSpreadInProgress","newBook","remove","classForMode","setShowingBleed","prevScroll","setProgressAmount","fragment","renderFunctionFor","estimatedProgress","scroller","scrollH","renderProgress","needsZoomUpdate","sideBySide","limit","pgs","pageSpread","spacer","insertBefore","scaleThatFits","viewerW","contentW","min","vals","Bindery","_g","_h","_j","autorun","view","printSetup","autoupdate","startLayout","startMarks","viewer","displayError","ControlsComponent","defaultRules","hide","display","contentDescription","getContentAsElement","message","clear","onProgress","currentBook","constants","View","Paper","Layout","Marks","version","assign"],"mappings":"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"}